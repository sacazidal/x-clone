"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/imagekitio-next";
exports.ids = ["vendor-chunks/imagekitio-next"];
exports.modules = {

/***/ "(ssr)/./node_modules/imagekitio-next/dist/imagekit-next.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/imagekitio-next/dist/imagekit-next.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IKImage: () => (/* binding */ IKImage),\n/* harmony export */   IKUpload: () => (/* binding */ IKUpload),\n/* harmony export */   IKVideo: () => (/* binding */ IKVideo),\n/* harmony export */   ImageKitClient: () => (/* binding */ ImageKit),\n/* harmony export */   ImageKitContext: () => (/* binding */ ImageKitContext),\n/* harmony export */   ImageKitProvider: () => (/* binding */ ImageKitProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n\n\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar version = \"3.0.2\";\n\nvar errorMessages = {\n  MANDATORY_INITIALIZATION_MISSING: {\n    message: \"Missing urlEndpoint during SDK initialization\",\n    help: \"\"\n  },\n  INVALID_TRANSFORMATION_POSITION: {\n    message: \"Invalid transformationPosition parameter\",\n    help: \"\"\n  },\n  PRIVATE_KEY_CLIENT_SIDE: {\n    message: \"privateKey should not be passed on the client side\",\n    help: \"\"\n  },\n  MISSING_UPLOAD_DATA: {\n    message: \"Missing data for upload\",\n    help: \"\"\n  },\n  MISSING_UPLOAD_FILE_PARAMETER: {\n    message: \"Missing file parameter for upload\",\n    help: \"\"\n  },\n  MISSING_UPLOAD_FILENAME_PARAMETER: {\n    message: \"Missing fileName parameter for upload\",\n    help: \"\"\n  },\n  MISSING_AUTHENTICATION_ENDPOINT: {\n    message: \"Missing authentication endpoint for upload\",\n    help: \"\"\n  },\n  MISSING_PUBLIC_KEY: {\n    message: \"Missing public key for upload\",\n    help: \"\"\n  },\n  AUTH_ENDPOINT_TIMEOUT: {\n    message: \"The authenticationEndpoint you provided timed out in 60 seconds\",\n    help: \"\"\n  },\n  AUTH_ENDPOINT_NETWORK_ERROR: {\n    message: \"Request to authenticationEndpoint failed due to network error\",\n    help: \"\"\n  },\n  AUTH_INVALID_RESPONSE: {\n    message: \"Invalid response from authenticationEndpoint. The SDK expects a JSON response with three fields i.e. signature, token and expire.\",\n    help: \"\"\n  },\n  UPLOAD_ENDPOINT_NETWORK_ERROR: {\n    message: \"Request to ImageKit upload endpoint failed due to network error\",\n    help: \"\"\n  },\n  INVALID_UPLOAD_OPTIONS: {\n    message: \"Invalid uploadOptions parameter\",\n    help: \"\"\n  },\n  MISSING_SIGNATURE: {\n    message: \"Missing signature for upload. The SDK expects token, signature and expire for authentication.\",\n    help: \"\"\n  },\n  MISSING_TOKEN: {\n    message: \"Missing token for upload. The SDK expects token, signature and expire for authentication.\",\n    help: \"\"\n  },\n  MISSING_EXPIRE: {\n    message: \"Missing expire for upload. The SDK expects token, signature and expire for authentication.\",\n    help: \"\"\n  },\n  INVALID_TRANSFORMATION: {\n    message: \"Invalid transformation parameter. Please include at least pre, post, or both.\",\n    help: \"\"\n  },\n  INVALID_PRE_TRANSFORMATION: {\n    message: \"Invalid pre transformation parameter.\",\n    help: \"\"\n  },\n  INVALID_POST_TRANSFORMATION: {\n    message: \"Invalid post transformation parameter.\",\n    help: \"\"\n  }\n};\n\nfunction respond (isError, response, callback) {\n  if (typeof callback == \"function\") {\n    if (isError) {\n      callback(response, null);\n    } else {\n      callback(null, response);\n    }\n  }\n}\n\nfunction getResponseHeaderMap(xhr) {\n  var headers = {};\n  var responseHeaders = xhr.getAllResponseHeaders();\n  if (Object.keys(responseHeaders).length) {\n    responseHeaders.trim().split(/[\\r\\n]+/).map(function (value) {\n      return value.split(/: /);\n    }).forEach(function (keyValue) {\n      headers[keyValue[0].trim()] = keyValue[1].trim();\n    });\n  }\n  return headers;\n}\nvar addResponseHeadersAndBody = function addResponseHeadersAndBody(body, xhr) {\n  var response = _objectSpread2({}, body);\n  var responseMetadata = {\n    statusCode: xhr.status,\n    headers: getResponseHeaderMap(xhr)\n  };\n  Object.defineProperty(response, \"$ResponseMetadata\", {\n    value: responseMetadata,\n    enumerable: false,\n    writable: false\n  });\n  return response;\n};\nvar request = function request(uploadFileXHR, formData, callback) {\n  uploadFile(uploadFileXHR, formData).then(function (result) {\n    return respond(false, result, callback);\n  }, function (ex) {\n    return respond(true, ex, callback);\n  });\n};\nvar uploadFile = function uploadFile(uploadFileXHR, formData) {\n  return new Promise(function (resolve, reject) {\n    uploadFileXHR.open('POST', 'https://upload.imagekit.io/api/v1/files/upload');\n    uploadFileXHR.onerror = function (e) {\n      return reject(errorMessages.UPLOAD_ENDPOINT_NETWORK_ERROR);\n    };\n    uploadFileXHR.onload = function () {\n      if (uploadFileXHR.status === 200) {\n        try {\n          var body = JSON.parse(uploadFileXHR.responseText);\n          var uploadResponse = addResponseHeadersAndBody(body, uploadFileXHR);\n          return resolve(uploadResponse);\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        try {\n          var body = JSON.parse(uploadFileXHR.responseText);\n          var uploadError = addResponseHeadersAndBody(body, uploadFileXHR);\n          return reject(uploadError);\n        } catch (ex) {\n          return reject(ex);\n        }\n      }\n    };\n    uploadFileXHR.send(formData);\n  });\n};\n\nvar upload = function upload(xhr, uploadOptions, options, callback) {\n  if (!uploadOptions.file) {\n    respond(true, errorMessages.MISSING_UPLOAD_FILE_PARAMETER, callback);\n    return;\n  }\n  if (!uploadOptions.fileName) {\n    respond(true, errorMessages.MISSING_UPLOAD_FILENAME_PARAMETER, callback);\n    return;\n  }\n  if (!options.publicKey) {\n    respond(true, errorMessages.MISSING_PUBLIC_KEY, callback);\n    return;\n  }\n  if (!uploadOptions.token) {\n    respond(true, errorMessages.MISSING_TOKEN, callback);\n    return;\n  }\n  if (!uploadOptions.signature) {\n    respond(true, errorMessages.MISSING_SIGNATURE, callback);\n    return;\n  }\n  if (!uploadOptions.expire) {\n    respond(true, errorMessages.MISSING_EXPIRE, callback);\n    return;\n  }\n  if (uploadOptions.transformation) {\n    if (!(Object.keys(uploadOptions.transformation).includes(\"pre\") || Object.keys(uploadOptions.transformation).includes(\"post\"))) {\n      respond(true, errorMessages.INVALID_TRANSFORMATION, callback);\n      return;\n    }\n    if (Object.keys(uploadOptions.transformation).includes(\"pre\") && !uploadOptions.transformation.pre) {\n      respond(true, errorMessages.INVALID_PRE_TRANSFORMATION, callback);\n      return;\n    }\n    if (Object.keys(uploadOptions.transformation).includes(\"post\")) {\n      if (Array.isArray(uploadOptions.transformation.post)) {\n        var _iterator = _createForOfIteratorHelper(uploadOptions.transformation.post),\n            _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var transformation = _step.value;\n            if (transformation.type === \"abs\" && !(transformation.protocol || transformation.value)) {\n              respond(true, errorMessages.INVALID_POST_TRANSFORMATION, callback);\n              return;\n            } else if (transformation.type === \"transformation\" && !transformation.value) {\n              respond(true, errorMessages.INVALID_POST_TRANSFORMATION, callback);\n              return;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        respond(true, errorMessages.INVALID_POST_TRANSFORMATION, callback);\n        return;\n      }\n    }\n  }\n  var formData = new FormData();\n  var key;\n  for (key in uploadOptions) {\n    if (key) {\n      if (key === \"file\" && typeof uploadOptions.file != \"string\") {\n        formData.append('file', uploadOptions.file, String(uploadOptions.fileName));\n      } else if (key === \"tags\" && Array.isArray(uploadOptions.tags)) {\n        formData.append('tags', uploadOptions.tags.join(\",\"));\n      } else if (key === 'signature') {\n        formData.append(\"signature\", uploadOptions.signature);\n      } else if (key === 'expire') {\n        formData.append(\"expire\", String(uploadOptions.expire));\n      } else if (key === 'token') {\n        formData.append(\"token\", uploadOptions.token);\n      } else if (key === \"responseFields\" && Array.isArray(uploadOptions.responseFields)) {\n        formData.append('responseFields', uploadOptions.responseFields.join(\",\"));\n      } else if (key === \"extensions\" && Array.isArray(uploadOptions.extensions)) {\n        formData.append('extensions', JSON.stringify(uploadOptions.extensions));\n      } else if (key === \"customMetadata\" && _typeof(uploadOptions.customMetadata) === \"object\" && !Array.isArray(uploadOptions.customMetadata) && uploadOptions.customMetadata !== null) {\n        formData.append('customMetadata', JSON.stringify(uploadOptions.customMetadata));\n      } else if (key === \"transformation\" && _typeof(uploadOptions.transformation) === \"object\" && uploadOptions.transformation !== null) {\n        formData.append(key, JSON.stringify(uploadOptions.transformation));\n      } else if (key === 'checks' && uploadOptions.checks) {\n        formData.append(\"checks\", uploadOptions.checks);\n      } else if (uploadOptions[key] !== undefined) {\n        formData.append(key, String(uploadOptions[key]));\n      }\n    }\n  }\n  formData.append(\"publicKey\", options.publicKey);\n  request(xhr, formData, callback);\n};\n\nvar supportedTransforms = {\n  width: \"w\",\n  height: \"h\",\n  aspectRatio: \"ar\",\n  quality: \"q\",\n  crop: \"c\",\n  cropMode: \"cm\",\n  focus: \"fo\",\n  x: \"x\",\n  y: \"y\",\n  format: \"f\",\n  radius: \"r\",\n  background: \"bg\",\n  border: \"b\",\n  rotation: \"rt\",\n  rotate: \"rt\",\n  blur: \"bl\",\n  named: \"n\",\n  progressive: \"pr\",\n  lossless: \"lo\",\n  trim: \"t\",\n  metadata: \"md\",\n  colorProfile: \"cp\",\n  defaultImage: \"di\",\n  dpr: \"dpr\",\n  effectSharpen: \"e-sharpen\",\n  effectUSM: \"e-usm\",\n  effectContrast: \"e-contrast\",\n  effectGray: \"e-grayscale\",\n  original: \"orig\",\n  effectShadow: \"e-shadow\",\n  effectGradient: \"e-gradient\",\n  raw: \"raw\"\n};\n\nvar DEFAULT_TRANSFORMATION_POSITION = \"path\";\nvar QUERY_TRANSFORMATION_POSITION = \"query\";\nvar VALID_TRANSFORMATION_POSITIONS = [DEFAULT_TRANSFORMATION_POSITION, QUERY_TRANSFORMATION_POSITION];\nvar CHAIN_TRANSFORM_DELIMITER = \":\";\nvar TRANSFORM_DELIMITER = \",\";\nvar TRANSFORM_KEY_VALUE_DELIMITER = \"-\";\nvar transformationUtils = {\n  getDefault: function getDefault() {\n    return DEFAULT_TRANSFORMATION_POSITION;\n  },\n  addAsQueryParameter: function addAsQueryParameter(options) {\n    return options.transformationPosition === QUERY_TRANSFORMATION_POSITION;\n  },\n  validParameters: function validParameters(options) {\n    if (typeof options.transformationPosition == \"undefined\") return false;\n    return VALID_TRANSFORMATION_POSITIONS.indexOf(options.transformationPosition) != -1;\n  },\n  getTransformKey: function getTransformKey(transform) {\n    if (!transform) {\n      return \"\";\n    }\n    return supportedTransforms[transform] || supportedTransforms[transform.toLowerCase()] || \"\";\n  },\n  getChainTransformDelimiter: function getChainTransformDelimiter() {\n    return CHAIN_TRANSFORM_DELIMITER;\n  },\n  getTransformDelimiter: function getTransformDelimiter() {\n    return TRANSFORM_DELIMITER;\n  },\n  getTransformKeyValueDelimiter: function getTransformKeyValueDelimiter() {\n    return TRANSFORM_KEY_VALUE_DELIMITER;\n  }\n};\n\nvar TRANSFORMATION_PARAMETER = \"tr\";\nfunction removeTrailingSlash(str) {\n  if (typeof str == \"string\" && str[str.length - 1] == \"/\") {\n    str = str.substring(0, str.length - 1);\n  }\n  return str;\n}\nfunction removeLeadingSlash(str) {\n  if (typeof str == \"string\" && str[0] == \"/\") {\n    str = str.slice(1);\n  }\n  return str;\n}\nfunction pathJoin(parts, sep) {\n  var separator = sep || \"/\";\n  var replace = new RegExp(separator + \"{1,}\", \"g\");\n  return parts.join(separator).replace(replace, separator);\n}\nvar buildURL = function buildURL(opts) {\n  if (!opts.path && !opts.src) {\n    return \"\";\n  }\n  var urlObj, isSrcParameterUsedForURL, urlEndpointPattern;\n  try {\n    if (opts.path) {\n      urlEndpointPattern = new URL(opts.urlEndpoint).pathname;\n      urlObj = new URL(pathJoin([opts.urlEndpoint.replace(urlEndpointPattern, \"\"), opts.path]));\n    } else {\n      urlObj = new URL(opts.src);\n      isSrcParameterUsedForURL = true;\n    }\n  } catch (e) {\n    console.error(e);\n    return \"\";\n  }\n  for (var i in opts.queryParameters) {\n    urlObj.searchParams.append(i, String(opts.queryParameters[i]));\n  }\n  var transformationString = constructTransformationString(opts.transformation);\n  if (transformationString && transformationString.length) {\n    if (transformationUtils.addAsQueryParameter(opts) || isSrcParameterUsedForURL) {\n      urlObj.searchParams.append(TRANSFORMATION_PARAMETER, transformationString);\n    } else {\n      urlObj.pathname = pathJoin([TRANSFORMATION_PARAMETER + transformationUtils.getChainTransformDelimiter() + transformationString, urlObj.pathname]);\n    }\n  }\n  if (urlEndpointPattern) {\n    urlObj.pathname = pathJoin([urlEndpointPattern, urlObj.pathname]);\n  } else {\n    urlObj.pathname = pathJoin([urlObj.pathname]);\n  }\n  return urlObj.href;\n};\nfunction constructTransformationString(transformation) {\n  if (!Array.isArray(transformation)) {\n    return \"\";\n  }\n  var parsedTransforms = [];\n  for (var i = 0, l = transformation.length; i < l; i++) {\n    var parsedTransformStep = [];\n    for (var key in transformation[i]) {\n      if (transformation[i][key] === undefined || transformation[i][key] === null) continue;\n      var transformKey = transformationUtils.getTransformKey(key);\n      if (!transformKey) {\n        transformKey = key;\n      }\n      if (transformation[i][key] === \"-\") {\n        parsedTransformStep.push(transformKey);\n      } else if (key === \"raw\") {\n        parsedTransformStep.push(transformation[i][key]);\n      } else {\n        var value = transformation[i][key];\n        if (transformKey === \"di\") {\n          value = removeTrailingSlash(removeLeadingSlash(value || \"\"));\n          value = value.replace(/\\//g, \"@@\");\n        }\n        parsedTransformStep.push([transformKey, value].join(transformationUtils.getTransformKeyValueDelimiter()));\n      }\n    }\n    parsedTransforms.push(parsedTransformStep.join(transformationUtils.getTransformDelimiter()));\n  }\n  return parsedTransforms.join(transformationUtils.getChainTransformDelimiter());\n}\n\nvar url = function url(urlOpts, defaultOptions) {\n  return buildURL(_objectSpread2(_objectSpread2({}, defaultOptions), urlOpts));\n};\n\nfunction mandatoryParametersAvailable(options) {\n  return options.urlEndpoint;\n}\nvar promisify = function promisify(thisContext, fn) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === fn.length && typeof args[args.length - 1] !== \"undefined\") {\n      if (typeof args[args.length - 1] !== \"function\") {\n        throw new Error(\"Callback must be a function.\");\n      }\n      fn.call.apply(fn, [thisContext].concat(args));\n    } else {\n      return new Promise(function (resolve, reject) {\n        var callback = function callback(err) {\n          if (err) {\n            return reject(err);\n          } else {\n            for (var _len2 = arguments.length, results = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              results[_key2 - 1] = arguments[_key2];\n            }\n            resolve(results.length > 1 ? results : results[0]);\n          }\n        };\n        args.pop();\n        args.push(callback);\n        fn.call.apply(fn, [thisContext].concat(args));\n      });\n    }\n  };\n};\nvar ImageKit = function () {\n  function ImageKit(opts) {\n    _classCallCheck(this, ImageKit);\n    _defineProperty(this, \"options\", {\n      sdkVersion: \"javascript-\".concat(version),\n      publicKey: \"\",\n      urlEndpoint: \"\",\n      transformationPosition: transformationUtils.getDefault()\n    });\n    this.options = _objectSpread2(_objectSpread2({}, this.options), opts || {});\n    if (!mandatoryParametersAvailable(this.options)) {\n      throw errorMessages.MANDATORY_INITIALIZATION_MISSING;\n    }\n    if (!transformationUtils.validParameters(this.options)) {\n      throw errorMessages.INVALID_TRANSFORMATION_POSITION;\n    }\n  }\n  _createClass(ImageKit, [{\n    key: \"url\",\n    value: function url$1(urlOptions) {\n      return url(urlOptions, this.options);\n    }\n  }, {\n    key: \"upload\",\n    value: function upload$1(uploadOptions, callbackOrOptions, options) {\n      var callback;\n      if (typeof callbackOrOptions === 'function') {\n        callback = callbackOrOptions;\n      } else {\n        options = callbackOrOptions || {};\n      }\n      if (!uploadOptions || _typeof(uploadOptions) !== \"object\") {\n        return respond(true, errorMessages.INVALID_UPLOAD_OPTIONS, callback);\n      }\n      var mergedOptions = _objectSpread2(_objectSpread2({}, this.options), options);\n      var _ref = uploadOptions || {},\n          userProvidedXHR = _ref.xhr;\n      delete uploadOptions.xhr;\n      var xhr = userProvidedXHR || new XMLHttpRequest();\n      return promisify(this, upload)(xhr, uploadOptions, mergedOptions, callback);\n    }\n  }]);\n  return ImageKit;\n}();\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n// Create the context\nconst ImageKitContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n/**\n * Provides a container for ImageKit components. Any option set in ImageKitProvider will be passed to the children.\n *\n * @example\n *<ImageKitProvider  publicKey=\"<public key>\" urlEndpoint=\"url link\">\n *    <!-- other tags -->\n *    <Image src={link}/>\n *</ImageKitProvider>\n */\nconst ImageKitProvider = props => {\n  const extractContextOptions = mergedOptions => {\n    const propKeys = [\"publicKey\", \"urlEndpoint\", \"authenticator\", \"transformationPosition\", \"ikClient\"];\n    for (const key in mergedOptions) {\n      if (!propKeys.includes(key)) {\n        delete mergedOptions[key];\n      }\n    }\n    return mergedOptions;\n  };\n  const mergedOptions = Object.assign({}, props);\n  const contextOptionsExtracted = extractContextOptions(mergedOptions);\n  if (contextOptionsExtracted.urlEndpoint && contextOptionsExtracted.urlEndpoint.trim() !== \"\") {\n    contextOptionsExtracted.ikClient = new ImageKit({\n      urlEndpoint: contextOptionsExtracted.urlEndpoint,\n      // @ts-ignore\n      sdkVersion: \"\"\n    });\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ImageKitContext.Provider, {\n    value: contextOptionsExtracted\n  }, props.children);\n};\n\nconst useImageKitComponent = props => {\n  const contextOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  const getIKClient = () => {\n    if (contextOptions && contextOptions.ikClient) {\n      return contextOptions.ikClient;\n    }\n    let {\n      urlEndpoint\n    } = props;\n    urlEndpoint = urlEndpoint || contextOptions && contextOptions.urlEndpoint;\n    if (!urlEndpoint || urlEndpoint.trim() === \"\") {\n      throw new Error(\"Missing urlEndpoint during initialization\");\n    }\n    const ikClient = new ImageKit({\n      urlEndpoint: urlEndpoint,\n      // @ts-ignore\n      sdkVersion: \"\"\n    });\n    return ikClient;\n  };\n  return {\n    getIKClient\n  };\n};\n\nconst fetchEffectiveConnection = () => {\n  try {\n    return navigator.connection.effectiveType;\n  } catch (ex) {\n    return \"4g\";\n  }\n};\nconst getSrc = ({\n  urlEndpoint,\n  lqip,\n  src,\n  path,\n  transformation,\n  transformationPosition,\n  queryParameters\n}, ikClient, contextOptions) => {\n  let options;\n  if (src) {\n    options = {\n      urlEndpoint: urlEndpoint || contextOptions.urlEndpoint,\n      src,\n      transformation: transformation || undefined,\n      transformationPosition: transformationPosition || contextOptions.transformationPosition || undefined,\n      queryParameters: queryParameters || {}\n    };\n  } else if (path) {\n    options = {\n      urlEndpoint: urlEndpoint || contextOptions.urlEndpoint,\n      path,\n      transformation: transformation || undefined,\n      transformationPosition: transformationPosition || contextOptions.transformationPosition || undefined,\n      queryParameters: queryParameters || {}\n    };\n  } else return {\n    originalSrc: \"\"\n  };\n  const result = {\n    originalSrc: ikClient.url(options)\n  };\n  if (lqip && lqip.active) {\n    var quality = Math.round(lqip.quality || lqip.threshold || 20);\n    var blur = Math.round(lqip.blur || 6);\n    var newTransformation = options.transformation ? [...options.transformation] : [];\n    if (lqip.raw && typeof lqip.raw === \"string\" && lqip.raw.trim() !== \"\") {\n      newTransformation.push({\n        raw: lqip.raw.trim()\n      });\n    } else {\n      newTransformation.push({\n        quality: String(quality),\n        blur: String(blur)\n      });\n    }\n    result.lqipSrc = ikClient.url(Object.assign(Object.assign({}, options), {\n      transformation: newTransformation\n    }));\n  }\n  return result;\n};\nconst getIKElementsUrl = ({\n  lqip = null,\n  loading\n}, {\n  intersected,\n  originalSrcLoaded,\n  originalSrc,\n  lqipSrc\n}) => {\n  /*\n      No lazy loading no lqip\n        src=originalImage\n      No lazy loading lqip\n        src=lqip\n        src=originalImage (when loaded)\n      lazy loading and no lqip\n        src=''\n        onIntersect:\n        src=originalImage\n      lazy loading and lqip\n        src=lqip\n        onIntersect:\n        src=originalImage (when loaded)\n    */\n  const isLqipActive = lqip => lqip && lqip.active;\n  if (loading !== \"lazy\" && !isLqipActive(lqip)) {\n    return originalSrc;\n  } else if (loading !== \"lazy\" && isLqipActive(lqip)) {\n    if (originalSrcLoaded) {\n      return originalSrc;\n    } else {\n      return lqipSrc;\n    }\n  } else if (loading === \"lazy\" && !isLqipActive(lqip)) {\n    if (intersected) {\n      return originalSrc;\n    } else {\n      return \"\";\n    }\n  } else {\n    if (intersected && originalSrcLoaded) {\n      return originalSrc;\n    } else {\n      return lqipSrc;\n    }\n  }\n};\nfunction hasProperty(array, property) {\n  return array.some(obj => obj.hasOwnProperty(property));\n}\nconst updateTransformation = ({\n  width,\n  height,\n  transformation,\n  src,\n  path,\n  quality\n}) => {\n  //if height and width are there in props and absent in transformation then add it to the transformatiion\n  if ((src || path) && (width || quality || height)) {\n    let transformationObject = {};\n    if (!((transformation === null || transformation === void 0 ? void 0 : transformation.length) && (hasProperty(transformation, \"height\") || hasProperty(transformation, \"width\")))) {\n      if (height) transformationObject[\"height\"] = String(height);\n      if (width) transformationObject[\"width\"] = String(width);\n    }\n    if (!((transformation === null || transformation === void 0 ? void 0 : transformation.length) && hasProperty(transformation, \"quality\")) && quality) transformationObject[\"quality\"] = String(quality);\n    if (Object.keys(transformationObject).length) {\n      if (transformation === null || transformation === void 0 ? void 0 : transformation.length) transformation = [...transformation, transformationObject];else transformation = [transformationObject];\n    }\n  }\n  return transformation;\n};\n\nconst IKImage = props => {\n  const [currentUrl, setCurrentUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n  const [imageProps, setImageProps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const [originalSrc, setOriginalSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  const [lqipSrc, setLqipSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  const [originalSrcLoaded, setOriginalSrcLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [observe, setObserve] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n  const [initialized, setInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [intersected, setIntersected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const {\n    getIKClient\n  } = useImageKitComponent(Object.assign({}, props));\n  const contextOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const {\n      originalSrc: newOriginalSrc,\n      lqipSrc: newLqipSrc\n    } = getSrc(Object.assign(Object.assign({}, props), {\n      transformation: updateTransformation(props)\n    }), getIKClient(), contextOptions);\n    setOriginalSrc(newOriginalSrc);\n    setLqipSrc(newLqipSrc ? newLqipSrc : \"\");\n    setInitialized(true);\n  }, [contextOptions, props]);\n  const updateImageUrl = () => __awaiter(void 0, void 0, void 0, function* () {\n    const url = yield getIKElementsUrl(props, {\n      originalSrc,\n      lqipSrc,\n      intersected,\n      contextOptions,\n      initialzeState: initialized,\n      originalSrcLoaded,\n      observe\n    }); // Include intersected state\n    if (url) {\n      setCurrentUrl(url);\n    }\n  });\n  const triggerOriginalImageLoad = () => {\n    var img = new Image();\n    img.onload = () => {\n      setOriginalSrcLoaded(true);\n    };\n    img.src = originalSrc;\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (originalSrcLoaded) updateImageUrl();\n  }, [originalSrcLoaded]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const image = imageRef.current;\n    const {\n      loading\n    } = props;\n    if (initialized) {\n      if (window && \"IntersectionObserver\" in window && loading === \"lazy\" && lqip) {\n        const connectionType = fetchEffectiveConnection();\n        let rootMargin = \"1250px\";\n        if (connectionType !== \"4g\") rootMargin = \"2500px\";\n        const imageObserver = new IntersectionObserver(entries => {\n          const el = entries[0];\n          if (el && el.isIntersecting && !intersected) {\n            setIntersected(true);\n            setObserve(prevObserver => {\n              if (prevObserver) {\n                prevObserver.disconnect();\n              }\n              return undefined;\n            });\n            triggerOriginalImageLoad();\n            updateImageUrl();\n          }\n        }, {\n          rootMargin: `${rootMargin} 0px ${rootMargin} 0px`\n        });\n        if (image) {\n          imageObserver.observe(image);\n          setObserve(imageObserver);\n        }\n      } else {\n        setIntersected(true);\n        triggerOriginalImageLoad();\n        updateImageUrl();\n      }\n    }\n    return () => {\n      if (observe) {\n        observe.disconnect();\n      }\n    };\n  }, [props, originalSrc, lqipSrc]);\n  const {\n      urlEndpoint,\n      authenticator,\n      publicKey,\n      loading,\n      lqip,\n      path,\n      src,\n      transformation,\n      transformationPosition,\n      queryParameters,\n      alt\n    } = props,\n    restProps = __rest(props, [\"urlEndpoint\", \"authenticator\", \"publicKey\", \"loading\", \"lqip\", \"path\", \"src\", \"transformation\", \"transformationPosition\", \"queryParameters\", \"alt\"]);\n  const restPropsWithoutImageProps = __rest(restProps, [\"fill\", \"quality\", \"priority\", \"placeholder\", \"blurDataURL\", \"unoptimized\", \"overrideSrc\", \"onLoadingComplete\", \"layout\", \"objectFit\", \"objectPosition\", \"lazyBoundary\", \"lazyRoot\"]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // if height and width are there in transformation skip props height and width and add fill =true\n    const updatedRestProps = restProps;\n    if ((transformation === null || transformation === void 0 ? void 0 : transformation.length) && transformation.some(obj => obj.hasOwnProperty(\"height\") || obj.hasOwnProperty(\"width\"))) {\n      if (updatedRestProps.height) delete updatedRestProps[\"height\"];\n      if (updatedRestProps.width) delete updatedRestProps[\"width\"];\n      updatedRestProps[\"fill\"] = true;\n    }\n    setImageProps(updatedRestProps);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (lqip === null || lqip === void 0 ? void 0 : lqip.active) console.warn(\"In [imagekitio-next], loading is set to eager when LQIP is used.\");\n  }, [lqip]);\n  return currentUrl != undefined && Object.keys(imageProps).length ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Object.assign({\n    loader: ({\n      src\n    }) => src,\n    alt: alt,\n    src: currentUrl ? currentUrl : \"\",\n    ref: imageRef,\n    unoptimized: true,\n    loading: (lqip === null || lqip === void 0 ? void 0 : lqip.active) ? \"eager\" : loading\n  }, imageProps)) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", Object.assign({\n    src: currentUrl ? currentUrl : undefined,\n    ref: imageRef\n  }, restPropsWithoutImageProps));\n};\n\nconst IKUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const contextOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  const {\n    getIKClient\n  } = useImageKitComponent(Object.assign({}, props));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const abort = () => {\n      if (state.xhr) {\n        state.xhr.abort();\n      }\n    };\n    if (ref && typeof ref === \"object\" && ref.hasOwnProperty(\"current\")) {\n      const refObject = ref;\n      refObject.current.abort = abort;\n    }\n  }, [state.xhr, ref]);\n  const {\n      publicKey,\n      urlEndpoint,\n      authenticator,\n      fileName,\n      useUniqueFileName,\n      tags,\n      folder,\n      isPrivateFile,\n      customCoordinates,\n      responseFields,\n      onError,\n      onSuccess,\n      onUploadStart,\n      onUploadProgress,\n      validateFile,\n      webhookUrl,\n      overwriteFile,\n      overwriteAITags,\n      overwriteTags,\n      overwriteCustomMetadata,\n      extensions,\n      customMetadata,\n      transformation,\n      overrideParameters,\n      checks\n    } = props,\n    restProps = __rest(props, [\"publicKey\", \"urlEndpoint\", \"authenticator\", \"fileName\", \"useUniqueFileName\", \"tags\", \"folder\", \"isPrivateFile\", \"customCoordinates\", \"responseFields\", \"onError\", \"onSuccess\", \"onUploadStart\", \"onUploadProgress\", \"validateFile\", \"webhookUrl\", \"overwriteFile\", \"overwriteAITags\", \"overwriteTags\", \"overwriteCustomMetadata\", \"extensions\", \"customMetadata\", \"transformation\", \"overrideParameters\", \"checks\"]);\n  const uploadFile = e => {\n    var _a;\n    const publicKey = props.publicKey || contextOptions.publicKey;\n    const authenticator = props.authenticator || contextOptions.authenticator;\n    const urlEndpoint = props.urlEndpoint || contextOptions.urlEndpoint;\n    if (!publicKey || publicKey.trim() === \"\") {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"Missing publicKey\"\n        });\n      }\n      return;\n    }\n    if (!authenticator) {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"The authenticator function is not provided.\"\n        });\n      }\n      return;\n    }\n    if (typeof authenticator !== \"function\") {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"The provided authenticator is not a function.\"\n        });\n      }\n      return;\n    }\n    if (!urlEndpoint || urlEndpoint.trim() === \"\") {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"Missing urlEndpoint\"\n        });\n      }\n      return;\n    }\n    var ikClient = getIKClient();\n    const file = (_a = e.target.files) === null || _a === void 0 ? void 0 : _a[0];\n    if (!file) {\n      return;\n    }\n    if (props.validateFile && !props.validateFile(file)) {\n      return;\n    }\n    if (props.onUploadStart && typeof props.onUploadStart === \"function\") {\n      props.onUploadStart(e);\n    }\n    let overrideValues = {};\n    if (props.overrideParameters && typeof props.overrideParameters === \"function\") {\n      overrideValues = props.overrideParameters(file) || {};\n    }\n    const xhr = new XMLHttpRequest();\n    const progressCb = e => {\n      if (props.onUploadProgress && typeof props.onUploadProgress === \"function\") {\n        props.onUploadProgress(e);\n      }\n    };\n    xhr.upload.addEventListener(\"progress\", progressCb);\n    var params = {\n      file: file,\n      fileName: overrideValues.fileName || fileName || file.name,\n      useUniqueFileName: overrideValues.useUniqueFileName || useUniqueFileName,\n      tags: overrideValues.tags || tags,\n      folder: overrideValues.folder || folder,\n      isPrivateFile: overrideValues.isPrivateFile || isPrivateFile,\n      customCoordinates: overrideValues.customCoordinates || customCoordinates,\n      responseFields,\n      extensions: overrideValues.extensions || extensions,\n      webhookUrl: overrideValues.webhookUrl || webhookUrl,\n      overwriteFile: overrideValues.overwriteFile || overwriteFile,\n      overwriteAITags: overrideValues.overwriteAITags || overwriteAITags,\n      overwriteTags: overrideValues.overwriteTags || overwriteTags,\n      overwriteCustomMetadata: overrideValues.overwriteCustomMetadata || overwriteCustomMetadata,\n      customMetadata: overrideValues.customMetadata || customMetadata,\n      signature: \"\",\n      expire: 0,\n      token: \"\",\n      xhr,\n      transformation: overrideValues.transformation || transformation,\n      checks: overrideValues.checks || checks\n    };\n    const authPromise = authenticator();\n    if (!(authPromise instanceof Promise)) {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"The authenticator function is expected to return a Promise instance.\"\n        });\n      }\n      return;\n    }\n    authPromise.then(({\n      signature,\n      token,\n      expire\n    }) => {\n      params[\"signature\"] = signature;\n      params[\"expire\"] = expire;\n      params[\"token\"] = token;\n      ikClient.upload(params, (err, result) => {\n        if (err) {\n          if (onError && typeof onError === \"function\") {\n            onError(err);\n          }\n        } else {\n          if (onSuccess && typeof onSuccess === \"function\") {\n            onSuccess(result);\n          }\n        }\n        xhr.upload.removeEventListener(\"progress\", progressCb);\n      }, {\n        publicKey\n      });\n      setState({\n        xhr\n      });\n    }).catch(data => {\n      var error;\n      if (data instanceof Array) {\n        error = data[0];\n      } else {\n        error = data;\n      }\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: String(error)\n        });\n      }\n      return;\n    });\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", Object.assign({}, restProps, {\n    ref: ref,\n    type: \"file\",\n    onChange: e => {\n      if (props.onChange && typeof props.onChange === \"function\") {\n        props.onChange(e);\n      }\n      uploadFile(e);\n    }\n  }));\n});\n\nconst IKVideo = props => {\n  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    currentUrl: \"\",\n    contextOptions: {}\n  });\n  const {\n    getIKClient\n  } = useImageKitComponent(Object.assign({}, props));\n  const contextItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const {\n      originalSrc\n    } = getSrc(props, getIKClient(), contextItems);\n    setState(prevState => Object.assign(Object.assign({}, prevState), {\n      currentUrl: originalSrc,\n      contextOptions: contextItems\n    }));\n  }, [contextItems, props]);\n  const {\n    currentUrl\n  } = state;\n  const restProps = __rest(props, [\"urlEndpoint\", \"publicKey\", \"authenticator\", \"path\", \"src\", \"transformation\", \"transformationPosition\", \"queryParameters\"]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"video\", Object.assign({}, restProps, {\n    ref: videoRef,\n    key: currentUrl\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"source\", {\n    src: currentUrl || undefined,\n    type: \"video/mp4\"\n  }));\n};\n\n\n//# sourceMappingURL=imagekit-next.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1hZ2VraXRpby1uZXh0L2Rpc3QvaW1hZ2VraXQtbmV4dC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWtHO0FBQy9EOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtB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QUMzQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsMERBQW1CLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsNkNBQU07QUFDekIsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksdUNBQXVDO0FBQzNDLHVCQUF1QixpREFBVTtBQUNqQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMsMERBQW1CLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0EsR0FBRyxHQUFHLDBEQUFtQjtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVxRztBQUNyRyIsInNvdXJjZXMiOlsiRDpcXHd3d1xceC1jbG9uZVxcbm9kZV9tb2R1bGVzXFxpbWFnZWtpdGlvLW5leHRcXGRpc3RcXGltYWdla2l0LW5leHQuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTmV4dEltYWdlIGZyb20gJ25leHQvaW1hZ2UnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBlO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjAuMlwiO1xuXG52YXIgZXJyb3JNZXNzYWdlcyA9IHtcbiAgTUFOREFUT1JZX0lOSVRJQUxJWkFUSU9OX01JU1NJTkc6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgdXJsRW5kcG9pbnQgZHVyaW5nIFNESyBpbml0aWFsaXphdGlvblwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgSU5WQUxJRF9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTjoge1xuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCB0cmFuc2Zvcm1hdGlvblBvc2l0aW9uIHBhcmFtZXRlclwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgUFJJVkFURV9LRVlfQ0xJRU5UX1NJREU6IHtcbiAgICBtZXNzYWdlOiBcInByaXZhdGVLZXkgc2hvdWxkIG5vdCBiZSBwYXNzZWQgb24gdGhlIGNsaWVudCBzaWRlXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX1VQTE9BRF9EQVRBOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIGRhdGEgZm9yIHVwbG9hZFwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgTUlTU0lOR19VUExPQURfRklMRV9QQVJBTUVURVI6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZmlsZSBwYXJhbWV0ZXIgZm9yIHVwbG9hZFwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgTUlTU0lOR19VUExPQURfRklMRU5BTUVfUEFSQU1FVEVSOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIGZpbGVOYW1lIHBhcmFtZXRlciBmb3IgdXBsb2FkXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX0FVVEhFTlRJQ0FUSU9OX0VORFBPSU5UOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIGF1dGhlbnRpY2F0aW9uIGVuZHBvaW50IGZvciB1cGxvYWRcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIE1JU1NJTkdfUFVCTElDX0tFWToge1xuICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBwdWJsaWMga2V5IGZvciB1cGxvYWRcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIEFVVEhfRU5EUE9JTlRfVElNRU9VVDoge1xuICAgIG1lc3NhZ2U6IFwiVGhlIGF1dGhlbnRpY2F0aW9uRW5kcG9pbnQgeW91IHByb3ZpZGVkIHRpbWVkIG91dCBpbiA2MCBzZWNvbmRzXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBBVVRIX0VORFBPSU5UX05FVFdPUktfRVJST1I6IHtcbiAgICBtZXNzYWdlOiBcIlJlcXVlc3QgdG8gYXV0aGVudGljYXRpb25FbmRwb2ludCBmYWlsZWQgZHVlIHRvIG5ldHdvcmsgZXJyb3JcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIEFVVEhfSU5WQUxJRF9SRVNQT05TRToge1xuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCByZXNwb25zZSBmcm9tIGF1dGhlbnRpY2F0aW9uRW5kcG9pbnQuIFRoZSBTREsgZXhwZWN0cyBhIEpTT04gcmVzcG9uc2Ugd2l0aCB0aHJlZSBmaWVsZHMgaS5lLiBzaWduYXR1cmUsIHRva2VuIGFuZCBleHBpcmUuXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBVUExPQURfRU5EUE9JTlRfTkVUV09SS19FUlJPUjoge1xuICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCB0byBJbWFnZUtpdCB1cGxvYWQgZW5kcG9pbnQgZmFpbGVkIGR1ZSB0byBuZXR3b3JrIGVycm9yXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBJTlZBTElEX1VQTE9BRF9PUFRJT05TOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHVwbG9hZE9wdGlvbnMgcGFyYW1ldGVyXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX1NJR05BVFVSRToge1xuICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBzaWduYXR1cmUgZm9yIHVwbG9hZC4gVGhlIFNESyBleHBlY3RzIHRva2VuLCBzaWduYXR1cmUgYW5kIGV4cGlyZSBmb3IgYXV0aGVudGljYXRpb24uXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX1RPS0VOOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIHRva2VuIGZvciB1cGxvYWQuIFRoZSBTREsgZXhwZWN0cyB0b2tlbiwgc2lnbmF0dXJlIGFuZCBleHBpcmUgZm9yIGF1dGhlbnRpY2F0aW9uLlwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgTUlTU0lOR19FWFBJUkU6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwaXJlIGZvciB1cGxvYWQuIFRoZSBTREsgZXhwZWN0cyB0b2tlbiwgc2lnbmF0dXJlIGFuZCBleHBpcmUgZm9yIGF1dGhlbnRpY2F0aW9uLlwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgSU5WQUxJRF9UUkFOU0ZPUk1BVElPTjoge1xuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXIuIFBsZWFzZSBpbmNsdWRlIGF0IGxlYXN0IHByZSwgcG9zdCwgb3IgYm90aC5cIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIElOVkFMSURfUFJFX1RSQU5TRk9STUFUSU9OOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHByZSB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXIuXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBJTlZBTElEX1BPU1RfVFJBTlNGT1JNQVRJT046IHtcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgcG9zdCB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXIuXCIsXG4gICAgaGVscDogXCJcIlxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNwb25kIChpc0Vycm9yLCByZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoaXNFcnJvcikge1xuICAgICAgY2FsbGJhY2socmVzcG9uc2UsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyTWFwKHhocikge1xuICB2YXIgaGVhZGVycyA9IHt9O1xuICB2YXIgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICBpZiAoT2JqZWN0LmtleXMocmVzcG9uc2VIZWFkZXJzKS5sZW5ndGgpIHtcbiAgICByZXNwb25zZUhlYWRlcnMudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3BsaXQoLzogLyk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5VmFsdWUpIHtcbiAgICAgIGhlYWRlcnNba2V5VmFsdWVbMF0udHJpbSgpXSA9IGtleVZhbHVlWzFdLnRyaW0oKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbnZhciBhZGRSZXNwb25zZUhlYWRlcnNBbmRCb2R5ID0gZnVuY3Rpb24gYWRkUmVzcG9uc2VIZWFkZXJzQW5kQm9keShib2R5LCB4aHIpIHtcbiAgdmFyIHJlc3BvbnNlID0gX29iamVjdFNwcmVhZDIoe30sIGJvZHkpO1xuICB2YXIgcmVzcG9uc2VNZXRhZGF0YSA9IHtcbiAgICBzdGF0dXNDb2RlOiB4aHIuc3RhdHVzLFxuICAgIGhlYWRlcnM6IGdldFJlc3BvbnNlSGVhZGVyTWFwKHhocilcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCBcIiRSZXNwb25zZU1ldGFkYXRhXCIsIHtcbiAgICB2YWx1ZTogcmVzcG9uc2VNZXRhZGF0YSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG52YXIgcmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QodXBsb2FkRmlsZVhIUiwgZm9ybURhdGEsIGNhbGxiYWNrKSB7XG4gIHVwbG9hZEZpbGUodXBsb2FkRmlsZVhIUiwgZm9ybURhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiByZXNwb25kKGZhbHNlLCByZXN1bHQsIGNhbGxiYWNrKTtcbiAgfSwgZnVuY3Rpb24gKGV4KSB7XG4gICAgcmV0dXJuIHJlc3BvbmQodHJ1ZSwgZXgsIGNhbGxiYWNrKTtcbiAgfSk7XG59O1xudmFyIHVwbG9hZEZpbGUgPSBmdW5jdGlvbiB1cGxvYWRGaWxlKHVwbG9hZEZpbGVYSFIsIGZvcm1EYXRhKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdXBsb2FkRmlsZVhIUi5vcGVuKCdQT1NUJywgJ2h0dHBzOi8vdXBsb2FkLmltYWdla2l0LmlvL2FwaS92MS9maWxlcy91cGxvYWQnKTtcbiAgICB1cGxvYWRGaWxlWEhSLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHJlamVjdChlcnJvck1lc3NhZ2VzLlVQTE9BRF9FTkRQT0lOVF9ORVRXT1JLX0VSUk9SKTtcbiAgICB9O1xuICAgIHVwbG9hZEZpbGVYSFIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHVwbG9hZEZpbGVYSFIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2UodXBsb2FkRmlsZVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIHZhciB1cGxvYWRSZXNwb25zZSA9IGFkZFJlc3BvbnNlSGVhZGVyc0FuZEJvZHkoYm9keSwgdXBsb2FkRmlsZVhIUik7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodXBsb2FkUmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZSh1cGxvYWRGaWxlWEhSLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgdmFyIHVwbG9hZEVycm9yID0gYWRkUmVzcG9uc2VIZWFkZXJzQW5kQm9keShib2R5LCB1cGxvYWRGaWxlWEhSKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHVwbG9hZEVycm9yKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdXBsb2FkRmlsZVhIUi5zZW5kKGZvcm1EYXRhKTtcbiAgfSk7XG59O1xuXG52YXIgdXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKHhociwgdXBsb2FkT3B0aW9ucywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCF1cGxvYWRPcHRpb25zLmZpbGUpIHtcbiAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuTUlTU0lOR19VUExPQURfRklMRV9QQVJBTUVURVIsIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF1cGxvYWRPcHRpb25zLmZpbGVOYW1lKSB7XG4gICAgcmVzcG9uZCh0cnVlLCBlcnJvck1lc3NhZ2VzLk1JU1NJTkdfVVBMT0FEX0ZJTEVOQU1FX1BBUkFNRVRFUiwgY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIW9wdGlvbnMucHVibGljS2V5KSB7XG4gICAgcmVzcG9uZCh0cnVlLCBlcnJvck1lc3NhZ2VzLk1JU1NJTkdfUFVCTElDX0tFWSwgY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXVwbG9hZE9wdGlvbnMudG9rZW4pIHtcbiAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuTUlTU0lOR19UT0tFTiwgY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXVwbG9hZE9wdGlvbnMuc2lnbmF0dXJlKSB7XG4gICAgcmVzcG9uZCh0cnVlLCBlcnJvck1lc3NhZ2VzLk1JU1NJTkdfU0lHTkFUVVJFLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdXBsb2FkT3B0aW9ucy5leHBpcmUpIHtcbiAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuTUlTU0lOR19FWFBJUkUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pIHtcbiAgICBpZiAoIShPYmplY3Qua2V5cyh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKS5pbmNsdWRlcyhcInByZVwiKSB8fCBPYmplY3Qua2V5cyh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKS5pbmNsdWRlcyhcInBvc3RcIikpKSB7XG4gICAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuSU5WQUxJRF9UUkFOU0ZPUk1BVElPTiwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbikuaW5jbHVkZXMoXCJwcmVcIikgJiYgIXVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24ucHJlKSB7XG4gICAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuSU5WQUxJRF9QUkVfVFJBTlNGT1JNQVRJT04sIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pLmluY2x1ZGVzKFwicG9zdFwiKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5wb3N0KSkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5wb3N0KSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1hdGlvbi50eXBlID09PSBcImFic1wiICYmICEodHJhbnNmb3JtYXRpb24ucHJvdG9jb2wgfHwgdHJhbnNmb3JtYXRpb24udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5JTlZBTElEX1BPU1RfVFJBTlNGT1JNQVRJT04sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1hdGlvbi50eXBlID09PSBcInRyYW5zZm9ybWF0aW9uXCIgJiYgIXRyYW5zZm9ybWF0aW9uLnZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5JTlZBTElEX1BPU1RfVFJBTlNGT1JNQVRJT04sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuSU5WQUxJRF9QT1NUX1RSQU5TRk9STUFUSU9OLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHVwbG9hZE9wdGlvbnMpIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSBcImZpbGVcIiAmJiB0eXBlb2YgdXBsb2FkT3B0aW9ucy5maWxlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgdXBsb2FkT3B0aW9ucy5maWxlLCBTdHJpbmcodXBsb2FkT3B0aW9ucy5maWxlTmFtZSkpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwidGFnc1wiICYmIEFycmF5LmlzQXJyYXkodXBsb2FkT3B0aW9ucy50YWdzKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3RhZ3MnLCB1cGxvYWRPcHRpb25zLnRhZ3Muam9pbihcIixcIikpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzaWduYXR1cmUnKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcInNpZ25hdHVyZVwiLCB1cGxvYWRPcHRpb25zLnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4cGlyZScpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZXhwaXJlXCIsIFN0cmluZyh1cGxvYWRPcHRpb25zLmV4cGlyZSkpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICd0b2tlbicpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwidG9rZW5cIiwgdXBsb2FkT3B0aW9ucy50b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJyZXNwb25zZUZpZWxkc1wiICYmIEFycmF5LmlzQXJyYXkodXBsb2FkT3B0aW9ucy5yZXNwb25zZUZpZWxkcykpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdyZXNwb25zZUZpZWxkcycsIHVwbG9hZE9wdGlvbnMucmVzcG9uc2VGaWVsZHMuam9pbihcIixcIikpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZXh0ZW5zaW9uc1wiICYmIEFycmF5LmlzQXJyYXkodXBsb2FkT3B0aW9ucy5leHRlbnNpb25zKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2V4dGVuc2lvbnMnLCBKU09OLnN0cmluZ2lmeSh1cGxvYWRPcHRpb25zLmV4dGVuc2lvbnMpKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImN1c3RvbU1ldGFkYXRhXCIgJiYgX3R5cGVvZih1cGxvYWRPcHRpb25zLmN1c3RvbU1ldGFkYXRhKSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh1cGxvYWRPcHRpb25zLmN1c3RvbU1ldGFkYXRhKSAmJiB1cGxvYWRPcHRpb25zLmN1c3RvbU1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnY3VzdG9tTWV0YWRhdGEnLCBKU09OLnN0cmluZ2lmeSh1cGxvYWRPcHRpb25zLmN1c3RvbU1ldGFkYXRhKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ0cmFuc2Zvcm1hdGlvblwiICYmIF90eXBlb2YodXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbikgPT09IFwib2JqZWN0XCIgJiYgdXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCBKU09OLnN0cmluZ2lmeSh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NoZWNrcycgJiYgdXBsb2FkT3B0aW9ucy5jaGVja3MpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiY2hlY2tzXCIsIHVwbG9hZE9wdGlvbnMuY2hlY2tzKTtcbiAgICAgIH0gZWxzZSBpZiAodXBsb2FkT3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgU3RyaW5nKHVwbG9hZE9wdGlvbnNba2V5XSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3JtRGF0YS5hcHBlbmQoXCJwdWJsaWNLZXlcIiwgb3B0aW9ucy5wdWJsaWNLZXkpO1xuICByZXF1ZXN0KHhociwgZm9ybURhdGEsIGNhbGxiYWNrKTtcbn07XG5cbnZhciBzdXBwb3J0ZWRUcmFuc2Zvcm1zID0ge1xuICB3aWR0aDogXCJ3XCIsXG4gIGhlaWdodDogXCJoXCIsXG4gIGFzcGVjdFJhdGlvOiBcImFyXCIsXG4gIHF1YWxpdHk6IFwicVwiLFxuICBjcm9wOiBcImNcIixcbiAgY3JvcE1vZGU6IFwiY21cIixcbiAgZm9jdXM6IFwiZm9cIixcbiAgeDogXCJ4XCIsXG4gIHk6IFwieVwiLFxuICBmb3JtYXQ6IFwiZlwiLFxuICByYWRpdXM6IFwiclwiLFxuICBiYWNrZ3JvdW5kOiBcImJnXCIsXG4gIGJvcmRlcjogXCJiXCIsXG4gIHJvdGF0aW9uOiBcInJ0XCIsXG4gIHJvdGF0ZTogXCJydFwiLFxuICBibHVyOiBcImJsXCIsXG4gIG5hbWVkOiBcIm5cIixcbiAgcHJvZ3Jlc3NpdmU6IFwicHJcIixcbiAgbG9zc2xlc3M6IFwibG9cIixcbiAgdHJpbTogXCJ0XCIsXG4gIG1ldGFkYXRhOiBcIm1kXCIsXG4gIGNvbG9yUHJvZmlsZTogXCJjcFwiLFxuICBkZWZhdWx0SW1hZ2U6IFwiZGlcIixcbiAgZHByOiBcImRwclwiLFxuICBlZmZlY3RTaGFycGVuOiBcImUtc2hhcnBlblwiLFxuICBlZmZlY3RVU006IFwiZS11c21cIixcbiAgZWZmZWN0Q29udHJhc3Q6IFwiZS1jb250cmFzdFwiLFxuICBlZmZlY3RHcmF5OiBcImUtZ3JheXNjYWxlXCIsXG4gIG9yaWdpbmFsOiBcIm9yaWdcIixcbiAgZWZmZWN0U2hhZG93OiBcImUtc2hhZG93XCIsXG4gIGVmZmVjdEdyYWRpZW50OiBcImUtZ3JhZGllbnRcIixcbiAgcmF3OiBcInJhd1wiXG59O1xuXG52YXIgREVGQVVMVF9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTiA9IFwicGF0aFwiO1xudmFyIFFVRVJZX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OID0gXCJxdWVyeVwiO1xudmFyIFZBTElEX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OUyA9IFtERUZBVUxUX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OLCBRVUVSWV9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTl07XG52YXIgQ0hBSU5fVFJBTlNGT1JNX0RFTElNSVRFUiA9IFwiOlwiO1xudmFyIFRSQU5TRk9STV9ERUxJTUlURVIgPSBcIixcIjtcbnZhciBUUkFOU0ZPUk1fS0VZX1ZBTFVFX0RFTElNSVRFUiA9IFwiLVwiO1xudmFyIHRyYW5zZm9ybWF0aW9uVXRpbHMgPSB7XG4gIGdldERlZmF1bHQ6IGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfVFJBTlNGT1JNQVRJT05fUE9TSVRJT047XG4gIH0sXG4gIGFkZEFzUXVlcnlQYXJhbWV0ZXI6IGZ1bmN0aW9uIGFkZEFzUXVlcnlQYXJhbWV0ZXIob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnRyYW5zZm9ybWF0aW9uUG9zaXRpb24gPT09IFFVRVJZX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OO1xuICB9LFxuICB2YWxpZFBhcmFtZXRlcnM6IGZ1bmN0aW9uIHZhbGlkUGFyYW1ldGVycyhvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybWF0aW9uUG9zaXRpb24gPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBWQUxJRF9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTlMuaW5kZXhPZihvcHRpb25zLnRyYW5zZm9ybWF0aW9uUG9zaXRpb24pICE9IC0xO1xuICB9LFxuICBnZXRUcmFuc2Zvcm1LZXk6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUtleSh0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWRUcmFuc2Zvcm1zW3RyYW5zZm9ybV0gfHwgc3VwcG9ydGVkVHJhbnNmb3Jtc1t0cmFuc2Zvcm0udG9Mb3dlckNhc2UoKV0gfHwgXCJcIjtcbiAgfSxcbiAgZ2V0Q2hhaW5UcmFuc2Zvcm1EZWxpbWl0ZXI6IGZ1bmN0aW9uIGdldENoYWluVHJhbnNmb3JtRGVsaW1pdGVyKCkge1xuICAgIHJldHVybiBDSEFJTl9UUkFOU0ZPUk1fREVMSU1JVEVSO1xuICB9LFxuICBnZXRUcmFuc2Zvcm1EZWxpbWl0ZXI6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybURlbGltaXRlcigpIHtcbiAgICByZXR1cm4gVFJBTlNGT1JNX0RFTElNSVRFUjtcbiAgfSxcbiAgZ2V0VHJhbnNmb3JtS2V5VmFsdWVEZWxpbWl0ZXI6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUtleVZhbHVlRGVsaW1pdGVyKCkge1xuICAgIHJldHVybiBUUkFOU0ZPUk1fS0VZX1ZBTFVFX0RFTElNSVRFUjtcbiAgfVxufTtcblxudmFyIFRSQU5TRk9STUFUSU9OX1BBUkFNRVRFUiA9IFwidHJcIjtcbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2goc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PSBcIi9cIikge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkaW5nU2xhc2goc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgJiYgc3RyWzBdID09IFwiL1wiKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwYXRoSm9pbihwYXJ0cywgc2VwKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBzZXAgfHwgXCIvXCI7XG4gIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cChzZXBhcmF0b3IgKyBcInsxLH1cIiwgXCJnXCIpO1xuICByZXR1cm4gcGFydHMuam9pbihzZXBhcmF0b3IpLnJlcGxhY2UocmVwbGFjZSwgc2VwYXJhdG9yKTtcbn1cbnZhciBidWlsZFVSTCA9IGZ1bmN0aW9uIGJ1aWxkVVJMKG9wdHMpIHtcbiAgaWYgKCFvcHRzLnBhdGggJiYgIW9wdHMuc3JjKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgdmFyIHVybE9iaiwgaXNTcmNQYXJhbWV0ZXJVc2VkRm9yVVJMLCB1cmxFbmRwb2ludFBhdHRlcm47XG4gIHRyeSB7XG4gICAgaWYgKG9wdHMucGF0aCkge1xuICAgICAgdXJsRW5kcG9pbnRQYXR0ZXJuID0gbmV3IFVSTChvcHRzLnVybEVuZHBvaW50KS5wYXRobmFtZTtcbiAgICAgIHVybE9iaiA9IG5ldyBVUkwocGF0aEpvaW4oW29wdHMudXJsRW5kcG9pbnQucmVwbGFjZSh1cmxFbmRwb2ludFBhdHRlcm4sIFwiXCIpLCBvcHRzLnBhdGhdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybE9iaiA9IG5ldyBVUkwob3B0cy5zcmMpO1xuICAgICAgaXNTcmNQYXJhbWV0ZXJVc2VkRm9yVVJMID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZvciAodmFyIGkgaW4gb3B0cy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICB1cmxPYmouc2VhcmNoUGFyYW1zLmFwcGVuZChpLCBTdHJpbmcob3B0cy5xdWVyeVBhcmFtZXRlcnNbaV0pKTtcbiAgfVxuICB2YXIgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBjb25zdHJ1Y3RUcmFuc2Zvcm1hdGlvblN0cmluZyhvcHRzLnRyYW5zZm9ybWF0aW9uKTtcbiAgaWYgKHRyYW5zZm9ybWF0aW9uU3RyaW5nICYmIHRyYW5zZm9ybWF0aW9uU3RyaW5nLmxlbmd0aCkge1xuICAgIGlmICh0cmFuc2Zvcm1hdGlvblV0aWxzLmFkZEFzUXVlcnlQYXJhbWV0ZXIob3B0cykgfHwgaXNTcmNQYXJhbWV0ZXJVc2VkRm9yVVJMKSB7XG4gICAgICB1cmxPYmouc2VhcmNoUGFyYW1zLmFwcGVuZChUUkFOU0ZPUk1BVElPTl9QQVJBTUVURVIsIHRyYW5zZm9ybWF0aW9uU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsT2JqLnBhdGhuYW1lID0gcGF0aEpvaW4oW1RSQU5TRk9STUFUSU9OX1BBUkFNRVRFUiArIHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0Q2hhaW5UcmFuc2Zvcm1EZWxpbWl0ZXIoKSArIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB1cmxPYmoucGF0aG5hbWVdKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVybEVuZHBvaW50UGF0dGVybikge1xuICAgIHVybE9iai5wYXRobmFtZSA9IHBhdGhKb2luKFt1cmxFbmRwb2ludFBhdHRlcm4sIHVybE9iai5wYXRobmFtZV0pO1xuICB9IGVsc2Uge1xuICAgIHVybE9iai5wYXRobmFtZSA9IHBhdGhKb2luKFt1cmxPYmoucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gdXJsT2JqLmhyZWY7XG59O1xuZnVuY3Rpb24gY29uc3RydWN0VHJhbnNmb3JtYXRpb25TdHJpbmcodHJhbnNmb3JtYXRpb24pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRyYW5zZm9ybWF0aW9uKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHZhciBwYXJzZWRUcmFuc2Zvcm1zID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdHJhbnNmb3JtYXRpb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZFRyYW5zZm9ybVN0ZXAgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNmb3JtYXRpb25baV0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1hdGlvbltpXVtrZXldID09PSB1bmRlZmluZWQgfHwgdHJhbnNmb3JtYXRpb25baV1ba2V5XSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICB2YXIgdHJhbnNmb3JtS2V5ID0gdHJhbnNmb3JtYXRpb25VdGlscy5nZXRUcmFuc2Zvcm1LZXkoa2V5KTtcbiAgICAgIGlmICghdHJhbnNmb3JtS2V5KSB7XG4gICAgICAgIHRyYW5zZm9ybUtleSA9IGtleTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1hdGlvbltpXVtrZXldID09PSBcIi1cIikge1xuICAgICAgICBwYXJzZWRUcmFuc2Zvcm1TdGVwLnB1c2godHJhbnNmb3JtS2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJhd1wiKSB7XG4gICAgICAgIHBhcnNlZFRyYW5zZm9ybVN0ZXAucHVzaCh0cmFuc2Zvcm1hdGlvbltpXVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybWF0aW9uW2ldW2tleV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1LZXkgPT09IFwiZGlcIikge1xuICAgICAgICAgIHZhbHVlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChyZW1vdmVMZWFkaW5nU2xhc2godmFsdWUgfHwgXCJcIikpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwvL2csIFwiQEBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkVHJhbnNmb3JtU3RlcC5wdXNoKFt0cmFuc2Zvcm1LZXksIHZhbHVlXS5qb2luKHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0VHJhbnNmb3JtS2V5VmFsdWVEZWxpbWl0ZXIoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZWRUcmFuc2Zvcm1zLnB1c2gocGFyc2VkVHJhbnNmb3JtU3RlcC5qb2luKHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0VHJhbnNmb3JtRGVsaW1pdGVyKCkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkVHJhbnNmb3Jtcy5qb2luKHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0Q2hhaW5UcmFuc2Zvcm1EZWxpbWl0ZXIoKSk7XG59XG5cbnZhciB1cmwgPSBmdW5jdGlvbiB1cmwodXJsT3B0cywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ1aWxkVVJMKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0T3B0aW9ucyksIHVybE9wdHMpKTtcbn07XG5cbmZ1bmN0aW9uIG1hbmRhdG9yeVBhcmFtZXRlcnNBdmFpbGFibGUob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy51cmxFbmRwb2ludDtcbn1cbnZhciBwcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkodGhpc0NvbnRleHQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IGZuLmxlbmd0aCAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBmbi5jYWxsLmFwcGx5KGZuLCBbdGhpc0NvbnRleHRdLmNvbmNhdChhcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN1bHRzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cy5sZW5ndGggPiAxID8gcmVzdWx0cyA6IHJlc3VsdHNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgZm4uY2FsbC5hcHBseShmbiwgW3RoaXNDb250ZXh0XS5jb25jYXQoYXJncykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBJbWFnZUtpdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1hZ2VLaXQob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZUtpdCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICBzZGtWZXJzaW9uOiBcImphdmFzY3JpcHQtXCIuY29uY2F0KHZlcnNpb24pLFxuICAgICAgcHVibGljS2V5OiBcIlwiLFxuICAgICAgdXJsRW5kcG9pbnQ6IFwiXCIsXG4gICAgICB0cmFuc2Zvcm1hdGlvblBvc2l0aW9uOiB0cmFuc2Zvcm1hdGlvblV0aWxzLmdldERlZmF1bHQoKVxuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRzIHx8IHt9KTtcbiAgICBpZiAoIW1hbmRhdG9yeVBhcmFtZXRlcnNBdmFpbGFibGUodGhpcy5vcHRpb25zKSkge1xuICAgICAgdGhyb3cgZXJyb3JNZXNzYWdlcy5NQU5EQVRPUllfSU5JVElBTElaQVRJT05fTUlTU0lORztcbiAgICB9XG4gICAgaWYgKCF0cmFuc2Zvcm1hdGlvblV0aWxzLnZhbGlkUGFyYW1ldGVycyh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBlcnJvck1lc3NhZ2VzLklOVkFMSURfVFJBTlNGT1JNQVRJT05fUE9TSVRJT047XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDbGFzcyhJbWFnZUtpdCwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVybCQxKHVybE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB1cmwodXJsT3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZCQxKHVwbG9hZE9wdGlvbnMsIGNhbGxiYWNrT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrT3JPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2tPck9wdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gY2FsbGJhY2tPck9wdGlvbnMgfHwge307XG4gICAgICB9XG4gICAgICBpZiAoIXVwbG9hZE9wdGlvbnMgfHwgX3R5cGVvZih1cGxvYWRPcHRpb25zKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gcmVzcG9uZCh0cnVlLCBlcnJvck1lc3NhZ2VzLklOVkFMSURfVVBMT0FEX09QVElPTlMsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgdmFyIF9yZWYgPSB1cGxvYWRPcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHVzZXJQcm92aWRlZFhIUiA9IF9yZWYueGhyO1xuICAgICAgZGVsZXRlIHVwbG9hZE9wdGlvbnMueGhyO1xuICAgICAgdmFyIHhociA9IHVzZXJQcm92aWRlZFhIUiB8fCBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcywgdXBsb2FkKSh4aHIsIHVwbG9hZE9wdGlvbnMsIG1lcmdlZE9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEltYWdlS2l0O1xufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8vIENyZWF0ZSB0aGUgY29udGV4dFxuY29uc3QgSW1hZ2VLaXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG4vKipcbiAqIFByb3ZpZGVzIGEgY29udGFpbmVyIGZvciBJbWFnZUtpdCBjb21wb25lbnRzLiBBbnkgb3B0aW9uIHNldCBpbiBJbWFnZUtpdFByb3ZpZGVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjaGlsZHJlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICo8SW1hZ2VLaXRQcm92aWRlciAgcHVibGljS2V5PVwiPHB1YmxpYyBrZXk+XCIgdXJsRW5kcG9pbnQ9XCJ1cmwgbGlua1wiPlxuICogICAgPCEtLSBvdGhlciB0YWdzIC0tPlxuICogICAgPEltYWdlIHNyYz17bGlua30vPlxuICo8L0ltYWdlS2l0UHJvdmlkZXI+XG4gKi9cbmNvbnN0IEltYWdlS2l0UHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGV4dHJhY3RDb250ZXh0T3B0aW9ucyA9IG1lcmdlZE9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHByb3BLZXlzID0gW1wicHVibGljS2V5XCIsIFwidXJsRW5kcG9pbnRcIiwgXCJhdXRoZW50aWNhdG9yXCIsIFwidHJhbnNmb3JtYXRpb25Qb3NpdGlvblwiLCBcImlrQ2xpZW50XCJdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1lcmdlZE9wdGlvbnMpIHtcbiAgICAgIGlmICghcHJvcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBkZWxldGUgbWVyZ2VkT3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkT3B0aW9ucztcbiAgfTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcbiAgY29uc3QgY29udGV4dE9wdGlvbnNFeHRyYWN0ZWQgPSBleHRyYWN0Q29udGV4dE9wdGlvbnMobWVyZ2VkT3B0aW9ucyk7XG4gIGlmIChjb250ZXh0T3B0aW9uc0V4dHJhY3RlZC51cmxFbmRwb2ludCAmJiBjb250ZXh0T3B0aW9uc0V4dHJhY3RlZC51cmxFbmRwb2ludC50cmltKCkgIT09IFwiXCIpIHtcbiAgICBjb250ZXh0T3B0aW9uc0V4dHJhY3RlZC5pa0NsaWVudCA9IG5ldyBJbWFnZUtpdCh7XG4gICAgICB1cmxFbmRwb2ludDogY29udGV4dE9wdGlvbnNFeHRyYWN0ZWQudXJsRW5kcG9pbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzZGtWZXJzaW9uOiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VLaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRPcHRpb25zRXh0cmFjdGVkXG4gIH0sIHByb3BzLmNoaWxkcmVuKTtcbn07XG5cbmNvbnN0IHVzZUltYWdlS2l0Q29tcG9uZW50ID0gcHJvcHMgPT4ge1xuICBjb25zdCBjb250ZXh0T3B0aW9ucyA9IHVzZUNvbnRleHQoSW1hZ2VLaXRDb250ZXh0KTtcbiAgY29uc3QgZ2V0SUtDbGllbnQgPSAoKSA9PiB7XG4gICAgaWYgKGNvbnRleHRPcHRpb25zICYmIGNvbnRleHRPcHRpb25zLmlrQ2xpZW50KSB7XG4gICAgICByZXR1cm4gY29udGV4dE9wdGlvbnMuaWtDbGllbnQ7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB1cmxFbmRwb2ludFxuICAgIH0gPSBwcm9wcztcbiAgICB1cmxFbmRwb2ludCA9IHVybEVuZHBvaW50IHx8IGNvbnRleHRPcHRpb25zICYmIGNvbnRleHRPcHRpb25zLnVybEVuZHBvaW50O1xuICAgIGlmICghdXJsRW5kcG9pbnQgfHwgdXJsRW5kcG9pbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHVybEVuZHBvaW50IGR1cmluZyBpbml0aWFsaXphdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgaWtDbGllbnQgPSBuZXcgSW1hZ2VLaXQoe1xuICAgICAgdXJsRW5kcG9pbnQ6IHVybEVuZHBvaW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2RrVmVyc2lvbjogXCJcIlxuICAgIH0pO1xuICAgIHJldHVybiBpa0NsaWVudDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRJS0NsaWVudFxuICB9O1xufTtcblxuY29uc3QgZmV0Y2hFZmZlY3RpdmVDb25uZWN0aW9uID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IuY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBcIjRnXCI7XG4gIH1cbn07XG5jb25zdCBnZXRTcmMgPSAoe1xuICB1cmxFbmRwb2ludCxcbiAgbHFpcCxcbiAgc3JjLFxuICBwYXRoLFxuICB0cmFuc2Zvcm1hdGlvbixcbiAgdHJhbnNmb3JtYXRpb25Qb3NpdGlvbixcbiAgcXVlcnlQYXJhbWV0ZXJzXG59LCBpa0NsaWVudCwgY29udGV4dE9wdGlvbnMpID0+IHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChzcmMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdXJsRW5kcG9pbnQ6IHVybEVuZHBvaW50IHx8IGNvbnRleHRPcHRpb25zLnVybEVuZHBvaW50LFxuICAgICAgc3JjLFxuICAgICAgdHJhbnNmb3JtYXRpb246IHRyYW5zZm9ybWF0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb246IHRyYW5zZm9ybWF0aW9uUG9zaXRpb24gfHwgY29udGV4dE9wdGlvbnMudHJhbnNmb3JtYXRpb25Qb3NpdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICBxdWVyeVBhcmFtZXRlcnM6IHF1ZXJ5UGFyYW1ldGVycyB8fCB7fVxuICAgIH07XG4gIH0gZWxzZSBpZiAocGF0aCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB1cmxFbmRwb2ludDogdXJsRW5kcG9pbnQgfHwgY29udGV4dE9wdGlvbnMudXJsRW5kcG9pbnQsXG4gICAgICBwYXRoLFxuICAgICAgdHJhbnNmb3JtYXRpb246IHRyYW5zZm9ybWF0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb246IHRyYW5zZm9ybWF0aW9uUG9zaXRpb24gfHwgY29udGV4dE9wdGlvbnMudHJhbnNmb3JtYXRpb25Qb3NpdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICBxdWVyeVBhcmFtZXRlcnM6IHF1ZXJ5UGFyYW1ldGVycyB8fCB7fVxuICAgIH07XG4gIH0gZWxzZSByZXR1cm4ge1xuICAgIG9yaWdpbmFsU3JjOiBcIlwiXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBvcmlnaW5hbFNyYzogaWtDbGllbnQudXJsKG9wdGlvbnMpXG4gIH07XG4gIGlmIChscWlwICYmIGxxaXAuYWN0aXZlKSB7XG4gICAgdmFyIHF1YWxpdHkgPSBNYXRoLnJvdW5kKGxxaXAucXVhbGl0eSB8fCBscWlwLnRocmVzaG9sZCB8fCAyMCk7XG4gICAgdmFyIGJsdXIgPSBNYXRoLnJvdW5kKGxxaXAuYmx1ciB8fCA2KTtcbiAgICB2YXIgbmV3VHJhbnNmb3JtYXRpb24gPSBvcHRpb25zLnRyYW5zZm9ybWF0aW9uID8gWy4uLm9wdGlvbnMudHJhbnNmb3JtYXRpb25dIDogW107XG4gICAgaWYgKGxxaXAucmF3ICYmIHR5cGVvZiBscWlwLnJhdyA9PT0gXCJzdHJpbmdcIiAmJiBscWlwLnJhdy50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgIG5ld1RyYW5zZm9ybWF0aW9uLnB1c2goe1xuICAgICAgICByYXc6IGxxaXAucmF3LnRyaW0oKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1RyYW5zZm9ybWF0aW9uLnB1c2goe1xuICAgICAgICBxdWFsaXR5OiBTdHJpbmcocXVhbGl0eSksXG4gICAgICAgIGJsdXI6IFN0cmluZyhibHVyKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC5scWlwU3JjID0gaWtDbGllbnQudXJsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgIHRyYW5zZm9ybWF0aW9uOiBuZXdUcmFuc2Zvcm1hdGlvblxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGdldElLRWxlbWVudHNVcmwgPSAoe1xuICBscWlwID0gbnVsbCxcbiAgbG9hZGluZ1xufSwge1xuICBpbnRlcnNlY3RlZCxcbiAgb3JpZ2luYWxTcmNMb2FkZWQsXG4gIG9yaWdpbmFsU3JjLFxuICBscWlwU3JjXG59KSA9PiB7XG4gIC8qXG4gICAgICBObyBsYXp5IGxvYWRpbmcgbm8gbHFpcFxuICAgICAgICBzcmM9b3JpZ2luYWxJbWFnZVxuICAgICAgTm8gbGF6eSBsb2FkaW5nIGxxaXBcbiAgICAgICAgc3JjPWxxaXBcbiAgICAgICAgc3JjPW9yaWdpbmFsSW1hZ2UgKHdoZW4gbG9hZGVkKVxuICAgICAgbGF6eSBsb2FkaW5nIGFuZCBubyBscWlwXG4gICAgICAgIHNyYz0nJ1xuICAgICAgICBvbkludGVyc2VjdDpcbiAgICAgICAgc3JjPW9yaWdpbmFsSW1hZ2VcbiAgICAgIGxhenkgbG9hZGluZyBhbmQgbHFpcFxuICAgICAgICBzcmM9bHFpcFxuICAgICAgICBvbkludGVyc2VjdDpcbiAgICAgICAgc3JjPW9yaWdpbmFsSW1hZ2UgKHdoZW4gbG9hZGVkKVxuICAgICovXG4gIGNvbnN0IGlzTHFpcEFjdGl2ZSA9IGxxaXAgPT4gbHFpcCAmJiBscWlwLmFjdGl2ZTtcbiAgaWYgKGxvYWRpbmcgIT09IFwibGF6eVwiICYmICFpc0xxaXBBY3RpdmUobHFpcCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxTcmM7XG4gIH0gZWxzZSBpZiAobG9hZGluZyAhPT0gXCJsYXp5XCIgJiYgaXNMcWlwQWN0aXZlKGxxaXApKSB7XG4gICAgaWYgKG9yaWdpbmFsU3JjTG9hZGVkKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxTcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBscWlwU3JjO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsb2FkaW5nID09PSBcImxhenlcIiAmJiAhaXNMcWlwQWN0aXZlKGxxaXApKSB7XG4gICAgaWYgKGludGVyc2VjdGVkKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxTcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaW50ZXJzZWN0ZWQgJiYgb3JpZ2luYWxTcmNMb2FkZWQpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbFNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxxaXBTcmM7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gaGFzUHJvcGVydHkoYXJyYXksIHByb3BlcnR5KSB7XG4gIHJldHVybiBhcnJheS5zb21lKG9iaiA9PiBvYmouaGFzT3duUHJvcGVydHkocHJvcGVydHkpKTtcbn1cbmNvbnN0IHVwZGF0ZVRyYW5zZm9ybWF0aW9uID0gKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgdHJhbnNmb3JtYXRpb24sXG4gIHNyYyxcbiAgcGF0aCxcbiAgcXVhbGl0eVxufSkgPT4ge1xuICAvL2lmIGhlaWdodCBhbmQgd2lkdGggYXJlIHRoZXJlIGluIHByb3BzIGFuZCBhYnNlbnQgaW4gdHJhbnNmb3JtYXRpb24gdGhlbiBhZGQgaXQgdG8gdGhlIHRyYW5zZm9ybWF0aWlvblxuICBpZiAoKHNyYyB8fCBwYXRoKSAmJiAod2lkdGggfHwgcXVhbGl0eSB8fCBoZWlnaHQpKSB7XG4gICAgbGV0IHRyYW5zZm9ybWF0aW9uT2JqZWN0ID0ge307XG4gICAgaWYgKCEoKHRyYW5zZm9ybWF0aW9uID09PSBudWxsIHx8IHRyYW5zZm9ybWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1hdGlvbi5sZW5ndGgpICYmIChoYXNQcm9wZXJ0eSh0cmFuc2Zvcm1hdGlvbiwgXCJoZWlnaHRcIikgfHwgaGFzUHJvcGVydHkodHJhbnNmb3JtYXRpb24sIFwid2lkdGhcIikpKSkge1xuICAgICAgaWYgKGhlaWdodCkgdHJhbnNmb3JtYXRpb25PYmplY3RbXCJoZWlnaHRcIl0gPSBTdHJpbmcoaGVpZ2h0KTtcbiAgICAgIGlmICh3aWR0aCkgdHJhbnNmb3JtYXRpb25PYmplY3RbXCJ3aWR0aFwiXSA9IFN0cmluZyh3aWR0aCk7XG4gICAgfVxuICAgIGlmICghKCh0cmFuc2Zvcm1hdGlvbiA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtYXRpb24ubGVuZ3RoKSAmJiBoYXNQcm9wZXJ0eSh0cmFuc2Zvcm1hdGlvbiwgXCJxdWFsaXR5XCIpKSAmJiBxdWFsaXR5KSB0cmFuc2Zvcm1hdGlvbk9iamVjdFtcInF1YWxpdHlcIl0gPSBTdHJpbmcocXVhbGl0eSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYW5zZm9ybWF0aW9uT2JqZWN0KS5sZW5ndGgpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1hdGlvbiA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtYXRpb24ubGVuZ3RoKSB0cmFuc2Zvcm1hdGlvbiA9IFsuLi50cmFuc2Zvcm1hdGlvbiwgdHJhbnNmb3JtYXRpb25PYmplY3RdO2Vsc2UgdHJhbnNmb3JtYXRpb24gPSBbdHJhbnNmb3JtYXRpb25PYmplY3RdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG59O1xuXG5jb25zdCBJS0ltYWdlID0gcHJvcHMgPT4ge1xuICBjb25zdCBbY3VycmVudFVybCwgc2V0Q3VycmVudFVybF0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xuICBjb25zdCBbaW1hZ2VQcm9wcywgc2V0SW1hZ2VQcm9wc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtvcmlnaW5hbFNyYywgc2V0T3JpZ2luYWxTcmNdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtscWlwU3JjLCBzZXRMcWlwU3JjXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbb3JpZ2luYWxTcmNMb2FkZWQsIHNldE9yaWdpbmFsU3JjTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW29ic2VydmUsIHNldE9ic2VydmVdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcbiAgY29uc3QgW2luaXRpYWxpemVkLCBzZXRJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpbnRlcnNlY3RlZCwgc2V0SW50ZXJzZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBpbWFnZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIGdldElLQ2xpZW50XG4gIH0gPSB1c2VJbWFnZUtpdENvbXBvbmVudChPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpO1xuICBjb25zdCBjb250ZXh0T3B0aW9ucyA9IHVzZUNvbnRleHQoSW1hZ2VLaXRDb250ZXh0KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvcmlnaW5hbFNyYzogbmV3T3JpZ2luYWxTcmMsXG4gICAgICBscWlwU3JjOiBuZXdMcWlwU3JjXG4gICAgfSA9IGdldFNyYyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwge1xuICAgICAgdHJhbnNmb3JtYXRpb246IHVwZGF0ZVRyYW5zZm9ybWF0aW9uKHByb3BzKVxuICAgIH0pLCBnZXRJS0NsaWVudCgpLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgc2V0T3JpZ2luYWxTcmMobmV3T3JpZ2luYWxTcmMpO1xuICAgIHNldExxaXBTcmMobmV3THFpcFNyYyA/IG5ld0xxaXBTcmMgOiBcIlwiKTtcbiAgICBzZXRJbml0aWFsaXplZCh0cnVlKTtcbiAgfSwgW2NvbnRleHRPcHRpb25zLCBwcm9wc10pO1xuICBjb25zdCB1cGRhdGVJbWFnZVVybCA9ICgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVybCA9IHlpZWxkIGdldElLRWxlbWVudHNVcmwocHJvcHMsIHtcbiAgICAgIG9yaWdpbmFsU3JjLFxuICAgICAgbHFpcFNyYyxcbiAgICAgIGludGVyc2VjdGVkLFxuICAgICAgY29udGV4dE9wdGlvbnMsXG4gICAgICBpbml0aWFsemVTdGF0ZTogaW5pdGlhbGl6ZWQsXG4gICAgICBvcmlnaW5hbFNyY0xvYWRlZCxcbiAgICAgIG9ic2VydmVcbiAgICB9KTsgLy8gSW5jbHVkZSBpbnRlcnNlY3RlZCBzdGF0ZVxuICAgIGlmICh1cmwpIHtcbiAgICAgIHNldEN1cnJlbnRVcmwodXJsKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCB0cmlnZ2VyT3JpZ2luYWxJbWFnZUxvYWQgPSAoKSA9PiB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBzZXRPcmlnaW5hbFNyY0xvYWRlZCh0cnVlKTtcbiAgICB9O1xuICAgIGltZy5zcmMgPSBvcmlnaW5hbFNyYztcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3JpZ2luYWxTcmNMb2FkZWQpIHVwZGF0ZUltYWdlVXJsKCk7XG4gIH0sIFtvcmlnaW5hbFNyY0xvYWRlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGltYWdlID0gaW1hZ2VSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nXG4gICAgfSA9IHByb3BzO1xuICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgaWYgKHdpbmRvdyAmJiBcIkludGVyc2VjdGlvbk9ic2VydmVyXCIgaW4gd2luZG93ICYmIGxvYWRpbmcgPT09IFwibGF6eVwiICYmIGxxaXApIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblR5cGUgPSBmZXRjaEVmZmVjdGl2ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgbGV0IHJvb3RNYXJnaW4gPSBcIjEyNTBweFwiO1xuICAgICAgICBpZiAoY29ubmVjdGlvblR5cGUgIT09IFwiNGdcIikgcm9vdE1hcmdpbiA9IFwiMjUwMHB4XCI7XG4gICAgICAgIGNvbnN0IGltYWdlT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgY29uc3QgZWwgPSBlbnRyaWVzWzBdO1xuICAgICAgICAgIGlmIChlbCAmJiBlbC5pc0ludGVyc2VjdGluZyAmJiAhaW50ZXJzZWN0ZWQpIHtcbiAgICAgICAgICAgIHNldEludGVyc2VjdGVkKHRydWUpO1xuICAgICAgICAgICAgc2V0T2JzZXJ2ZShwcmV2T2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgICAgICBpZiAocHJldk9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgcHJldk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyT3JpZ2luYWxJbWFnZUxvYWQoKTtcbiAgICAgICAgICAgIHVwZGF0ZUltYWdlVXJsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcm9vdE1hcmdpbjogYCR7cm9vdE1hcmdpbn0gMHB4ICR7cm9vdE1hcmdpbn0gMHB4YFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgaW1hZ2VPYnNlcnZlci5vYnNlcnZlKGltYWdlKTtcbiAgICAgICAgICBzZXRPYnNlcnZlKGltYWdlT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJbnRlcnNlY3RlZCh0cnVlKTtcbiAgICAgICAgdHJpZ2dlck9yaWdpbmFsSW1hZ2VMb2FkKCk7XG4gICAgICAgIHVwZGF0ZUltYWdlVXJsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAob2JzZXJ2ZSkge1xuICAgICAgICBvYnNlcnZlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbcHJvcHMsIG9yaWdpbmFsU3JjLCBscWlwU3JjXSk7XG4gIGNvbnN0IHtcbiAgICAgIHVybEVuZHBvaW50LFxuICAgICAgYXV0aGVudGljYXRvcixcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIGxvYWRpbmcsXG4gICAgICBscWlwLFxuICAgICAgcGF0aCxcbiAgICAgIHNyYyxcbiAgICAgIHRyYW5zZm9ybWF0aW9uLFxuICAgICAgdHJhbnNmb3JtYXRpb25Qb3NpdGlvbixcbiAgICAgIHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgIGFsdFxuICAgIH0gPSBwcm9wcyxcbiAgICByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInVybEVuZHBvaW50XCIsIFwiYXV0aGVudGljYXRvclwiLCBcInB1YmxpY0tleVwiLCBcImxvYWRpbmdcIiwgXCJscWlwXCIsIFwicGF0aFwiLCBcInNyY1wiLCBcInRyYW5zZm9ybWF0aW9uXCIsIFwidHJhbnNmb3JtYXRpb25Qb3NpdGlvblwiLCBcInF1ZXJ5UGFyYW1ldGVyc1wiLCBcImFsdFwiXSk7XG4gIGNvbnN0IHJlc3RQcm9wc1dpdGhvdXRJbWFnZVByb3BzID0gX19yZXN0KHJlc3RQcm9wcywgW1wiZmlsbFwiLCBcInF1YWxpdHlcIiwgXCJwcmlvcml0eVwiLCBcInBsYWNlaG9sZGVyXCIsIFwiYmx1ckRhdGFVUkxcIiwgXCJ1bm9wdGltaXplZFwiLCBcIm92ZXJyaWRlU3JjXCIsIFwib25Mb2FkaW5nQ29tcGxldGVcIiwgXCJsYXlvdXRcIiwgXCJvYmplY3RGaXRcIiwgXCJvYmplY3RQb3NpdGlvblwiLCBcImxhenlCb3VuZGFyeVwiLCBcImxhenlSb290XCJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBpZiBoZWlnaHQgYW5kIHdpZHRoIGFyZSB0aGVyZSBpbiB0cmFuc2Zvcm1hdGlvbiBza2lwIHByb3BzIGhlaWdodCBhbmQgd2lkdGggYW5kIGFkZCBmaWxsID10cnVlXG4gICAgY29uc3QgdXBkYXRlZFJlc3RQcm9wcyA9IHJlc3RQcm9wcztcbiAgICBpZiAoKHRyYW5zZm9ybWF0aW9uID09PSBudWxsIHx8IHRyYW5zZm9ybWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1hdGlvbi5sZW5ndGgpICYmIHRyYW5zZm9ybWF0aW9uLnNvbWUob2JqID0+IG9iai5oYXNPd25Qcm9wZXJ0eShcImhlaWdodFwiKSB8fCBvYmouaGFzT3duUHJvcGVydHkoXCJ3aWR0aFwiKSkpIHtcbiAgICAgIGlmICh1cGRhdGVkUmVzdFByb3BzLmhlaWdodCkgZGVsZXRlIHVwZGF0ZWRSZXN0UHJvcHNbXCJoZWlnaHRcIl07XG4gICAgICBpZiAodXBkYXRlZFJlc3RQcm9wcy53aWR0aCkgZGVsZXRlIHVwZGF0ZWRSZXN0UHJvcHNbXCJ3aWR0aFwiXTtcbiAgICAgIHVwZGF0ZWRSZXN0UHJvcHNbXCJmaWxsXCJdID0gdHJ1ZTtcbiAgICB9XG4gICAgc2V0SW1hZ2VQcm9wcyh1cGRhdGVkUmVzdFByb3BzKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChscWlwID09PSBudWxsIHx8IGxxaXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxxaXAuYWN0aXZlKSBjb25zb2xlLndhcm4oXCJJbiBbaW1hZ2VraXRpby1uZXh0XSwgbG9hZGluZyBpcyBzZXQgdG8gZWFnZXIgd2hlbiBMUUlQIGlzIHVzZWQuXCIpO1xuICB9LCBbbHFpcF0pO1xuICByZXR1cm4gY3VycmVudFVybCAhPSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMoaW1hZ2VQcm9wcykubGVuZ3RoID8gUmVhY3QuY3JlYXRlRWxlbWVudChOZXh0SW1hZ2UsIE9iamVjdC5hc3NpZ24oe1xuICAgIGxvYWRlcjogKHtcbiAgICAgIHNyY1xuICAgIH0pID0+IHNyYyxcbiAgICBhbHQ6IGFsdCxcbiAgICBzcmM6IGN1cnJlbnRVcmwgPyBjdXJyZW50VXJsIDogXCJcIixcbiAgICByZWY6IGltYWdlUmVmLFxuICAgIHVub3B0aW1pemVkOiB0cnVlLFxuICAgIGxvYWRpbmc6IChscWlwID09PSBudWxsIHx8IGxxaXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxxaXAuYWN0aXZlKSA/IFwiZWFnZXJcIiA6IGxvYWRpbmdcbiAgfSwgaW1hZ2VQcm9wcykpIDogUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICBzcmM6IGN1cnJlbnRVcmwgPyBjdXJyZW50VXJsIDogdW5kZWZpbmVkLFxuICAgIHJlZjogaW1hZ2VSZWZcbiAgfSwgcmVzdFByb3BzV2l0aG91dEltYWdlUHJvcHMpKTtcbn07XG5cbmNvbnN0IElLVXBsb2FkID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgY29udGV4dE9wdGlvbnMgPSB1c2VDb250ZXh0KEltYWdlS2l0Q29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICBnZXRJS0NsaWVudFxuICB9ID0gdXNlSW1hZ2VLaXRDb21wb25lbnQoT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZS54aHIpIHtcbiAgICAgICAgc3RhdGUueGhyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVmICYmIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiYgcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSkge1xuICAgICAgY29uc3QgcmVmT2JqZWN0ID0gcmVmO1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQuYWJvcnQgPSBhYm9ydDtcbiAgICB9XG4gIH0sIFtzdGF0ZS54aHIsIHJlZl0pO1xuICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICB1cmxFbmRwb2ludCxcbiAgICAgIGF1dGhlbnRpY2F0b3IsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIHVzZVVuaXF1ZUZpbGVOYW1lLFxuICAgICAgdGFncyxcbiAgICAgIGZvbGRlcixcbiAgICAgIGlzUHJpdmF0ZUZpbGUsXG4gICAgICBjdXN0b21Db29yZGluYXRlcyxcbiAgICAgIHJlc3BvbnNlRmllbGRzLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uU3VjY2VzcyxcbiAgICAgIG9uVXBsb2FkU3RhcnQsXG4gICAgICBvblVwbG9hZFByb2dyZXNzLFxuICAgICAgdmFsaWRhdGVGaWxlLFxuICAgICAgd2ViaG9va1VybCxcbiAgICAgIG92ZXJ3cml0ZUZpbGUsXG4gICAgICBvdmVyd3JpdGVBSVRhZ3MsXG4gICAgICBvdmVyd3JpdGVUYWdzLFxuICAgICAgb3ZlcndyaXRlQ3VzdG9tTWV0YWRhdGEsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgY3VzdG9tTWV0YWRhdGEsXG4gICAgICB0cmFuc2Zvcm1hdGlvbixcbiAgICAgIG92ZXJyaWRlUGFyYW1ldGVycyxcbiAgICAgIGNoZWNrc1xuICAgIH0gPSBwcm9wcyxcbiAgICByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInB1YmxpY0tleVwiLCBcInVybEVuZHBvaW50XCIsIFwiYXV0aGVudGljYXRvclwiLCBcImZpbGVOYW1lXCIsIFwidXNlVW5pcXVlRmlsZU5hbWVcIiwgXCJ0YWdzXCIsIFwiZm9sZGVyXCIsIFwiaXNQcml2YXRlRmlsZVwiLCBcImN1c3RvbUNvb3JkaW5hdGVzXCIsIFwicmVzcG9uc2VGaWVsZHNcIiwgXCJvbkVycm9yXCIsIFwib25TdWNjZXNzXCIsIFwib25VcGxvYWRTdGFydFwiLCBcIm9uVXBsb2FkUHJvZ3Jlc3NcIiwgXCJ2YWxpZGF0ZUZpbGVcIiwgXCJ3ZWJob29rVXJsXCIsIFwib3ZlcndyaXRlRmlsZVwiLCBcIm92ZXJ3cml0ZUFJVGFnc1wiLCBcIm92ZXJ3cml0ZVRhZ3NcIiwgXCJvdmVyd3JpdGVDdXN0b21NZXRhZGF0YVwiLCBcImV4dGVuc2lvbnNcIiwgXCJjdXN0b21NZXRhZGF0YVwiLCBcInRyYW5zZm9ybWF0aW9uXCIsIFwib3ZlcnJpZGVQYXJhbWV0ZXJzXCIsIFwiY2hlY2tzXCJdKTtcbiAgY29uc3QgdXBsb2FkRmlsZSA9IGUgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBwcm9wcy5wdWJsaWNLZXkgfHwgY29udGV4dE9wdGlvbnMucHVibGljS2V5O1xuICAgIGNvbnN0IGF1dGhlbnRpY2F0b3IgPSBwcm9wcy5hdXRoZW50aWNhdG9yIHx8IGNvbnRleHRPcHRpb25zLmF1dGhlbnRpY2F0b3I7XG4gICAgY29uc3QgdXJsRW5kcG9pbnQgPSBwcm9wcy51cmxFbmRwb2ludCB8fCBjb250ZXh0T3B0aW9ucy51cmxFbmRwb2ludDtcbiAgICBpZiAoIXB1YmxpY0tleSB8fCBwdWJsaWNLZXkudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9uRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBwdWJsaWNLZXlcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFhdXRoZW50aWNhdG9yKSB7XG4gICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9uRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiVGhlIGF1dGhlbnRpY2F0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGF1dGhlbnRpY2F0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvbkVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlRoZSBwcm92aWRlZCBhdXRoZW50aWNhdG9yIGlzIG5vdCBhIGZ1bmN0aW9uLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXVybEVuZHBvaW50IHx8IHVybEVuZHBvaW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvbkVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgdXJsRW5kcG9pbnRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlrQ2xpZW50ID0gZ2V0SUtDbGllbnQoKTtcbiAgICBjb25zdCBmaWxlID0gKF9hID0gZS50YXJnZXQuZmlsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICBpZiAoIWZpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZhbGlkYXRlRmlsZSAmJiAhcHJvcHMudmFsaWRhdGVGaWxlKGZpbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy5vblVwbG9hZFN0YXJ0ICYmIHR5cGVvZiBwcm9wcy5vblVwbG9hZFN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb3BzLm9uVXBsb2FkU3RhcnQoZSk7XG4gICAgfVxuICAgIGxldCBvdmVycmlkZVZhbHVlcyA9IHt9O1xuICAgIGlmIChwcm9wcy5vdmVycmlkZVBhcmFtZXRlcnMgJiYgdHlwZW9mIHByb3BzLm92ZXJyaWRlUGFyYW1ldGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvdmVycmlkZVZhbHVlcyA9IHByb3BzLm92ZXJyaWRlUGFyYW1ldGVycyhmaWxlKSB8fCB7fTtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYiA9IGUgPT4ge1xuICAgICAgaWYgKHByb3BzLm9uVXBsb2FkUHJvZ3Jlc3MgJiYgdHlwZW9mIHByb3BzLm9uVXBsb2FkUHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm9wcy5vblVwbG9hZFByb2dyZXNzKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgcHJvZ3Jlc3NDYik7XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIGZpbGU6IGZpbGUsXG4gICAgICBmaWxlTmFtZTogb3ZlcnJpZGVWYWx1ZXMuZmlsZU5hbWUgfHwgZmlsZU5hbWUgfHwgZmlsZS5uYW1lLFxuICAgICAgdXNlVW5pcXVlRmlsZU5hbWU6IG92ZXJyaWRlVmFsdWVzLnVzZVVuaXF1ZUZpbGVOYW1lIHx8IHVzZVVuaXF1ZUZpbGVOYW1lLFxuICAgICAgdGFnczogb3ZlcnJpZGVWYWx1ZXMudGFncyB8fCB0YWdzLFxuICAgICAgZm9sZGVyOiBvdmVycmlkZVZhbHVlcy5mb2xkZXIgfHwgZm9sZGVyLFxuICAgICAgaXNQcml2YXRlRmlsZTogb3ZlcnJpZGVWYWx1ZXMuaXNQcml2YXRlRmlsZSB8fCBpc1ByaXZhdGVGaWxlLFxuICAgICAgY3VzdG9tQ29vcmRpbmF0ZXM6IG92ZXJyaWRlVmFsdWVzLmN1c3RvbUNvb3JkaW5hdGVzIHx8IGN1c3RvbUNvb3JkaW5hdGVzLFxuICAgICAgcmVzcG9uc2VGaWVsZHMsXG4gICAgICBleHRlbnNpb25zOiBvdmVycmlkZVZhbHVlcy5leHRlbnNpb25zIHx8IGV4dGVuc2lvbnMsXG4gICAgICB3ZWJob29rVXJsOiBvdmVycmlkZVZhbHVlcy53ZWJob29rVXJsIHx8IHdlYmhvb2tVcmwsXG4gICAgICBvdmVyd3JpdGVGaWxlOiBvdmVycmlkZVZhbHVlcy5vdmVyd3JpdGVGaWxlIHx8IG92ZXJ3cml0ZUZpbGUsXG4gICAgICBvdmVyd3JpdGVBSVRhZ3M6IG92ZXJyaWRlVmFsdWVzLm92ZXJ3cml0ZUFJVGFncyB8fCBvdmVyd3JpdGVBSVRhZ3MsXG4gICAgICBvdmVyd3JpdGVUYWdzOiBvdmVycmlkZVZhbHVlcy5vdmVyd3JpdGVUYWdzIHx8IG92ZXJ3cml0ZVRhZ3MsXG4gICAgICBvdmVyd3JpdGVDdXN0b21NZXRhZGF0YTogb3ZlcnJpZGVWYWx1ZXMub3ZlcndyaXRlQ3VzdG9tTWV0YWRhdGEgfHwgb3ZlcndyaXRlQ3VzdG9tTWV0YWRhdGEsXG4gICAgICBjdXN0b21NZXRhZGF0YTogb3ZlcnJpZGVWYWx1ZXMuY3VzdG9tTWV0YWRhdGEgfHwgY3VzdG9tTWV0YWRhdGEsXG4gICAgICBzaWduYXR1cmU6IFwiXCIsXG4gICAgICBleHBpcmU6IDAsXG4gICAgICB0b2tlbjogXCJcIixcbiAgICAgIHhocixcbiAgICAgIHRyYW5zZm9ybWF0aW9uOiBvdmVycmlkZVZhbHVlcy50cmFuc2Zvcm1hdGlvbiB8fCB0cmFuc2Zvcm1hdGlvbixcbiAgICAgIGNoZWNrczogb3ZlcnJpZGVWYWx1ZXMuY2hlY2tzIHx8IGNoZWNrc1xuICAgIH07XG4gICAgY29uc3QgYXV0aFByb21pc2UgPSBhdXRoZW50aWNhdG9yKCk7XG4gICAgaWYgKCEoYXV0aFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvbkVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlRoZSBhdXRoZW50aWNhdG9yIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIFByb21pc2UgaW5zdGFuY2UuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF1dGhQcm9taXNlLnRoZW4oKHtcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHRva2VuLFxuICAgICAgZXhwaXJlXG4gICAgfSkgPT4ge1xuICAgICAgcGFyYW1zW1wic2lnbmF0dXJlXCJdID0gc2lnbmF0dXJlO1xuICAgICAgcGFyYW1zW1wiZXhwaXJlXCJdID0gZXhwaXJlO1xuICAgICAgcGFyYW1zW1widG9rZW5cIl0gPSB0b2tlbjtcbiAgICAgIGlrQ2xpZW50LnVwbG9hZChwYXJhbXMsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob25TdWNjZXNzICYmIHR5cGVvZiBvblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhoci51cGxvYWQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHByb2dyZXNzQ2IpO1xuICAgICAgfSwge1xuICAgICAgICBwdWJsaWNLZXlcbiAgICAgIH0pO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICB4aHJcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGRhdGEgPT4ge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlcnJvciA9IGRhdGFbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IGRhdGE7XG4gICAgICB9XG4gICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9uRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFN0cmluZyhlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzLCB7XG4gICAgcmVmOiByZWYsXG4gICAgdHlwZTogXCJmaWxlXCIsXG4gICAgb25DaGFuZ2U6IGUgPT4ge1xuICAgICAgaWYgKHByb3BzLm9uQ2hhbmdlICYmIHR5cGVvZiBwcm9wcy5vbkNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKGUpO1xuICAgICAgfVxuICAgICAgdXBsb2FkRmlsZShlKTtcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5jb25zdCBJS1ZpZGVvID0gcHJvcHMgPT4ge1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSh7XG4gICAgY3VycmVudFVybDogXCJcIixcbiAgICBjb250ZXh0T3B0aW9uczoge31cbiAgfSk7XG4gIGNvbnN0IHtcbiAgICBnZXRJS0NsaWVudFxuICB9ID0gdXNlSW1hZ2VLaXRDb21wb25lbnQoT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKTtcbiAgY29uc3QgY29udGV4dEl0ZW1zID0gdXNlQ29udGV4dChJbWFnZUtpdENvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9yaWdpbmFsU3JjXG4gICAgfSA9IGdldFNyYyhwcm9wcywgZ2V0SUtDbGllbnQoKSwgY29udGV4dEl0ZW1zKTtcbiAgICBzZXRTdGF0ZShwcmV2U3RhdGUgPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2U3RhdGUpLCB7XG4gICAgICBjdXJyZW50VXJsOiBvcmlnaW5hbFNyYyxcbiAgICAgIGNvbnRleHRPcHRpb25zOiBjb250ZXh0SXRlbXNcbiAgICB9KSk7XG4gIH0sIFtjb250ZXh0SXRlbXMsIHByb3BzXSk7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50VXJsXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcmVzdFByb3BzID0gX19yZXN0KHByb3BzLCBbXCJ1cmxFbmRwb2ludFwiLCBcInB1YmxpY0tleVwiLCBcImF1dGhlbnRpY2F0b3JcIiwgXCJwYXRoXCIsIFwic3JjXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ0cmFuc2Zvcm1hdGlvblBvc2l0aW9uXCIsIFwicXVlcnlQYXJhbWV0ZXJzXCJdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0UHJvcHMsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIGtleTogY3VycmVudFVybFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiLCB7XG4gICAgc3JjOiBjdXJyZW50VXJsIHx8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiBcInZpZGVvL21wNFwiXG4gIH0pKTtcbn07XG5cbmV4cG9ydCB7IElLSW1hZ2UsIElLVXBsb2FkLCBJS1ZpZGVvLCBJbWFnZUtpdCBhcyBJbWFnZUtpdENsaWVudCwgSW1hZ2VLaXRDb250ZXh0LCBJbWFnZUtpdFByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZWtpdC1uZXh0LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/imagekitio-next/dist/imagekit-next.esm.js\n");

/***/ })

};
;